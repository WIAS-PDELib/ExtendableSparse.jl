<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sparse matrix handling · ExtendableSparse.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtendableSparse.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../example/">Examples &amp; Benchmarks</a></li><li class="is-active"><a class="tocitem" href>Sparse matrix handling</a><ul class="internal"><li><a class="tocitem" href="#Matrix-creation-and-update-API"><span>Matrix creation and update API</span></a></li><li><a class="tocitem" href="#Test-matrix-creation"><span>Test matrix creation</span></a></li></ul></li><li><a class="tocitem" href="../iter/">Factorizations &amp; Preconditioners</a></li><li><a class="tocitem" href="../internal/">Internal API</a></li><li><a class="tocitem" href="../changes/">Changes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sparse matrix handling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sparse matrix handling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/j-fu/ExtendableSparse.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sparse-matrix-handling"><a class="docs-heading-anchor" href="#Sparse-matrix-handling">Sparse matrix handling</a><a id="Sparse-matrix-handling-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-matrix-handling" title="Permalink"></a></h1><h2 id="Matrix-creation-and-update-API"><a class="docs-heading-anchor" href="#Matrix-creation-and-update-API">Matrix creation and update API</a><a id="Matrix-creation-and-update-API-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-creation-and-update-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.ExtendableSparseMatrix" href="#ExtendableSparse.ExtendableSparseMatrix"><code>ExtendableSparse.ExtendableSparseMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct ExtendableSparseMatrix{Tv, Ti&lt;:Integer} &lt;: SparseArrays.AbstractSparseArray{Tv, Ti&lt;:Integer, 2}</code></pre><p>Extendable sparse matrix. A nonzero  entry of this matrix is contained either in cscmatrix, or in lnkmatrix, never in both.</p><ul><li><code>cscmatrix::SparseArrays.SparseMatrixCSC</code>: Final matrix data</li></ul><ul><li><code>lnkmatrix::Union{Nothing, SparseMatrixLNK{Tv, Ti}} where {Tv, Ti&lt;:Integer}</code>: Linked list structure holding data of extension</li></ul><ul><li><code>phash::UInt64</code>: Pattern hash</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.ExtendableSparseMatrix-Tuple{AbstractMatrix}" href="#ExtendableSparse.ExtendableSparseMatrix-Tuple{AbstractMatrix}"><code>ExtendableSparse.ExtendableSparseMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExtendableSparseMatrix(A)
</code></pre><p>Create ExtendableSparseMatrix from AbstractMatrix, dropping all zero entries.  This is the equivalent to <code>sparse(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.ExtendableSparseMatrix-Tuple{Any, Any, AbstractVector}" href="#ExtendableSparse.ExtendableSparseMatrix-Tuple{Any, Any, AbstractVector}"><code>ExtendableSparse.ExtendableSparseMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExtendableSparseMatrix(I,J,V)
ExtendableSparseMatrix(I,J,V,m,n)
ExtendableSparseMatrix(I,J,V,combine::Function)
ExtendableSparseMatrix(I,J,V,m,n,combine::Function)</code></pre><p>Create ExtendableSparseMatrix from triplet (COO) data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.ExtendableSparseMatrix-Tuple{LinearAlgebra.Diagonal}" href="#ExtendableSparse.ExtendableSparseMatrix-Tuple{LinearAlgebra.Diagonal}"><code>ExtendableSparse.ExtendableSparseMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExtendableSparseMatrix(D)
</code></pre><p>Create ExtendableSparseMatrix from Diagonal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti&lt;:Integer}" href="#ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti&lt;:Integer}"><code>ExtendableSparse.ExtendableSparseMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExtendableSparseMatrix(csc)
</code></pre><p>Create ExtendableSparseMatrix from SparseMatrixCSC</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Any, Any}} where {Tv, Ti&lt;:Integer}" href="#ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Any, Any}} where {Tv, Ti&lt;:Integer}"><code>ExtendableSparse.ExtendableSparseMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExtendableSparseMatrix(Tv,Ti,m,n)
ExtendableSparseMatrix(Tv,m,n)
ExtendableSparseMatrix(m,n)</code></pre><p>Create empty ExtendableSparseMatrix. This is equivalent to <code>spzeros(m,n)</code> for <code>SparseMartrixCSC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{ExtendableSparseMatrix, LinearAlgebra.Diagonal}" href="#Base.:*-Tuple{ExtendableSparseMatrix, LinearAlgebra.Diagonal}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(ext, d)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{LinearAlgebra.Diagonal, ExtendableSparseMatrix}" href="#Base.:*-Tuple{LinearAlgebra.Diagonal, ExtendableSparseMatrix}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(d, ext)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{ExtendableSparseMatrix, SparseArrays.SparseMatrixCSC}" href="#Base.:+-Tuple{ExtendableSparseMatrix, SparseArrays.SparseMatrixCSC}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(ext, csc)
</code></pre><p>Add SparseMatrixCSC matrix and <a href="#ExtendableSparse.ExtendableSparseMatrix"><code>ExtendableSparseMatrix</code></a>  ext.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{ExtendableSparseMatrix, SparseArrays.SparseMatrixCSC}" href="#Base.:--Tuple{ExtendableSparseMatrix, SparseArrays.SparseMatrixCSC}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(ext, csc)
</code></pre><p>Subtract  SparseMatrixCSC matrix from  <a href="#ExtendableSparse.ExtendableSparseMatrix"><code>ExtendableSparseMatrix</code></a>  ext.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{SparseArrays.SparseMatrixCSC, ExtendableSparseMatrix}" href="#Base.:--Tuple{SparseArrays.SparseMatrixCSC, ExtendableSparseMatrix}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">-(csc, ext)
</code></pre><p>Subtract  <a href="#ExtendableSparse.ExtendableSparseMatrix"><code>ExtendableSparseMatrix</code></a>  ext from  SparseMatrixCSC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{LinearAlgebra.Hermitian{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVector}} where {Tm, Ti}" href="#Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{LinearAlgebra.Hermitian{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVector}} where {Tm, Ti}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">\(symm_ext, B)
</code></pre><p><a href="#Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{LinearAlgebra.Hermitian{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVector}} where {Tm, Ti}"><code>\</code></a> for Hermitian{ExtendableSparse}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{LinearAlgebra.Symmetric{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVector}} where {Tm, Ti}" href="#Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{LinearAlgebra.Symmetric{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVector}} where {Tm, Ti}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">\(symm_ext, B)
</code></pre><p><a href="#Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{LinearAlgebra.Hermitian{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVector}} where {Tm, Ti}"><code>\</code></a> for Symmetric{ExtendableSparse}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti}" href="#Base.:\\-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, AbstractVector{Tv}}} where {Tv, Ti}"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">A</code></pre><p><a href="#Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{LinearAlgebra.Hermitian{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVector}} where {Tm, Ti}"><code>\</code></a> for ExtendableSparse. It calls the LU factorization form Sparspak.jl, unless GPL components are allowed  in the Julia sysimage and the floating point type of the matrix is Float64 or Complex64. In that case, Julias standard `` is called, which is realized via UMFPACK.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{ExtendableSparseMatrix}" href="#Base.copy-Tuple{ExtendableSparseMatrix}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(S)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any}} where {Tv, Ti&lt;:Integer}" href="#Base.getindex-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any}} where {Tv, Ti&lt;:Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(ext, i, j)
</code></pre><p>Find index in CSC matrix and return value, if it exists. Otherwise, return value from extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any}} where {Tv, Ti}" href="#Base.setindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any}} where {Tv, Ti}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(ext, v, i, j)
</code></pre><p>Find index in CSC matrix and set value if it exists. Otherwise, set index in extension if <code>v</code> is nonzero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, ExtendableSparseMatrix}" href="#Base.show-Tuple{IO, MIME{Symbol(&quot;text/plain&quot;)}, ExtendableSparseMatrix}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">show(io, _, ext)
</code></pre><p>Show matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.similar-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#Base.similar-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">similar(m)
</code></pre><p>Create similar but emtpy extendableSparseMatrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{ExtendableSparseMatrix}" href="#Base.size-Tuple{ExtendableSparseMatrix}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size(ext)
</code></pre><p>Size of ExtendableSparseMatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}" href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>ExtendableSparse.flush!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flush!(ext)
</code></pre><p>If there are new entries in extension, create new CSC matrix by adding the cscmatrix and linked list matrix and reset the linked list based extension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.rawupdateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti&lt;:Integer}" href="#ExtendableSparse.rawupdateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti&lt;:Integer}"><code>ExtendableSparse.rawupdateindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rawupdateindex!(ext, op, v, i, j)
</code></pre><p>Like <a href="#ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti&lt;:Integer}"><code>updateindex!</code></a> but without  checking if v is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti&lt;:Integer}" href="#ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti&lt;:Integer}"><code>ExtendableSparse.updateindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateindex!(ext, op, v, i, j)
</code></pre><p>Update element of the matrix  with operation <code>op</code>. This can replace the following code and save one index search during acces:</p><pre><code class="language- hljs">using ExtendableSparse # hide
A=ExtendableSparseMatrix(3,3)
A[1,2]+=0.1
A</code></pre><pre><code class="language- hljs">using ExtendableSparse # hide

A=ExtendableSparseMatrix(3,3)
updateindex!(A,+,0.1,1,2)
A</code></pre><p>If <code>v</code> is zero, no new entry is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.cond" href="#LinearAlgebra.cond"><code>LinearAlgebra.cond</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cond(A)
cond(A, p)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and calculate cond from cscmatrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.issymmetric-Tuple{ExtendableSparseMatrix}" href="#LinearAlgebra.issymmetric-Tuple{ExtendableSparseMatrix}"><code>LinearAlgebra.issymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">issymmetric(A)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and check for symmetry of cscmatrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.ldiv!-Tuple{Any, ExtendableSparseMatrix, Any}" href="#LinearAlgebra.ldiv!-Tuple{Any, ExtendableSparseMatrix, Any}"><code>LinearAlgebra.ldiv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ldiv!(r, ext, x)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and ldiv with ext.cscmatrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.mul!-Tuple{Any, ExtendableSparseMatrix, Any}" href="#LinearAlgebra.mul!-Tuple{Any, ExtendableSparseMatrix, Any}"><code>LinearAlgebra.mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mul!(r, ext, x)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and multiply with ext.cscmatrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">norm(A)
norm(A, p)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and calculate norm from cscmatrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.opnorm" href="#LinearAlgebra.opnorm"><code>LinearAlgebra.opnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">opnorm(A)
opnorm(A, p)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and calculate opnorm from cscmatrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.dropzeros!-Tuple{ExtendableSparseMatrix}" href="#SparseArrays.dropzeros!-Tuple{ExtendableSparseMatrix}"><code>SparseArrays.dropzeros!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dropzeros!(ext)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.findnz-Tuple{ExtendableSparseMatrix}" href="#SparseArrays.findnz-Tuple{ExtendableSparseMatrix}"><code>SparseArrays.findnz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findnz(ext)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and return findnz(ext.cscmatrix).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.getcolptr-Tuple{ExtendableSparseMatrix}" href="#SparseArrays.getcolptr-Tuple{ExtendableSparseMatrix}"><code>SparseArrays.getcolptr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getcolptr(ext)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and return colptr of  in ext.cscmatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nnz-Tuple{ExtendableSparseMatrix}" href="#SparseArrays.nnz-Tuple{ExtendableSparseMatrix}"><code>SparseArrays.nnz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nnz(ext)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and return number of nonzeros in ext.cscmatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.nonzeros-Tuple{ExtendableSparseMatrix}" href="#SparseArrays.nonzeros-Tuple{ExtendableSparseMatrix}"><code>SparseArrays.nonzeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nonzeros(ext)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and return nonzeros in ext.cscmatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.rowvals-Tuple{ExtendableSparseMatrix}" href="#SparseArrays.rowvals-Tuple{ExtendableSparseMatrix}"><code>SparseArrays.rowvals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rowvals(ext)
</code></pre><p><a href="#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}"><code>flush!</code></a> and return rowvals in ext.cscmatrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse-Tuple{ExtendableSparseMatrix}" href="#SparseArrays.sparse-Tuple{ExtendableSparseMatrix}"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sparse(A)
</code></pre><p>Create SparseMatrixCSC from ExtendableSparseMatrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><h2 id="Test-matrix-creation"><a class="docs-heading-anchor" href="#Test-matrix-creation">Test matrix creation</a><a id="Test-matrix-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Test-matrix-creation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.fdrand!-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}, Tuple{T, Any, Any, Any}} where T&lt;:(AbstractMatrix)" href="#ExtendableSparse.fdrand!-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}, Tuple{T, Any, Any, Any}} where T&lt;:(AbstractMatrix)"><code>ExtendableSparse.fdrand!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdrand!(A, nx)
fdrand!(A, nx, ny)
fdrand!(A, nx, ny, nz; update, rand)
</code></pre><p>After setting  all nonzero entries  to zero, fill resp.  update matrix with finite  difference discretization data  on a unit  hypercube. See <a href="#ExtendableSparse.fdrand-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Any}, Tuple{Type{T}, Any, Any, Any}} where T"><code>fdrand</code></a> for documentation of the parameters.</p><p>It is required that <code>size(A)==(N,N)</code> where <code>N=nx*ny*nz</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.fdrand-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Any}, Tuple{Type{T}, Any, Any, Any}} where T" href="#ExtendableSparse.fdrand-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Any}, Tuple{Type{T}, Any, Any, Any}} where T"><code>ExtendableSparse.fdrand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdrand(, nx)
fdrand(, nx, ny)
fdrand(, nx, ny, nz; matrixtype, update, rand, symmetric)
fdrand(nx)
</code></pre><p>Create matrix  for a mock  finite difference operator for  a diffusion problem with random coefficients on a unit hypercube <span>$\Omega\subset\mathbb R^d$</span>. with <span>$d=1$</span> if  <code>nx&gt;1 &amp;&amp; ny==1 &amp;&amp; nz==1</code>, <span>$d=2$</span> if  <code>nx&gt;1 &amp;&amp; ny&gt;1 &amp;&amp; nz==1</code> and <span>$d=3$</span> if  <code>nx&gt;1 &amp;&amp; ny&gt;1 &amp;&amp; nz&gt;1</code> . In the symmetric case it corresponds to</p><p class="math-container">\[    \begin{align*}
             -\nabla a \nabla u &amp;= f&amp;&amp;  \text{in}\;  \Omega  \\
    a\nabla u\cdot \vec n + bu &amp;=g &amp;&amp; \text{on}\;  \partial\Omega
    \end{align*}\]</p><p>The matrix is irreducibly diagonally dominant, has positive main diagonal entries  and nonpositive off-diagonal entries, hence it has the M-Property. Therefore, its inverse will be a dense matrix with positive entries, and the spectral radius of the  Jacobi iteration matrix <span>$ho(I-D(A)^{-1}A)&lt;1$</span> .</p><p>Moreover, in the symmetric case, it is positive definite.</p><p>Parameters+ default values:</p><table><tr><th style="text-align: right">Parameter + default vale</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: right"><code>nx</code></td><td style="text-align: left">Number of unknowns in x direction</td></tr><tr><td style="text-align: right"><code>ny</code></td><td style="text-align: left">Number of unknowns in y direction</td></tr><tr><td style="text-align: right"><code>nz</code></td><td style="text-align: left">Number of unknowns in z direction</td></tr><tr><td style="text-align: right"><code>matrixtype = SparseMatrixCSC</code></td><td style="text-align: left">Matrix type</td></tr><tr><td style="text-align: right"><code>update = (A,v,i,j)-&gt; A[i,j]+=v</code></td><td style="text-align: left">Element update function</td></tr><tr><td style="text-align: right"><code>rand =()-&gt; rand()</code></td><td style="text-align: left">Random number generator</td></tr><tr><td style="text-align: right"><code>symmetric=true</code></td><td style="text-align: left">Whether to create symmetric matrix or not</td></tr></table><p>The sparsity structure is fixed to an orthogonal grid, resulting in a 3, 5 or 7 diagonal matrix depending on dimension. The entries are random unless e.g.  <code>rand=()-&gt;1</code> is passed as random number generator. Tested for Matrix, SparseMatrixCSC,  ExtendableSparseMatrix, Tridiagonal, SparseMatrixLNK and <code>:COO</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.sprand!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.AbstractSparseMatrix{Tv, Ti}, Int64}} where {Tv, Ti}" href="#ExtendableSparse.sprand!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.AbstractSparseMatrix{Tv, Ti}, Int64}} where {Tv, Ti}"><code>ExtendableSparse.sprand!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sprand!(A, xnnz)
</code></pre><p>Fill empty sparse matrix A with random nonzero elements from interval [1,2] using incremental assembly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ExtendableSparse.sprand_sdd!-Union{Tuple{SparseArrays.AbstractSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}" href="#ExtendableSparse.sprand_sdd!-Union{Tuple{SparseArrays.AbstractSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}"><code>ExtendableSparse.sprand_sdd!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sprand_sdd!(A; nnzrow)
</code></pre><p>Fill sparse matrix  with random entries such that  it becomes strictly diagonally  dominant  and  thus  invertible and  has  a  fixed  number <code>nnzrow</code> (default: 4) of nonzeros in its rows. The matrix bandwidth is bounded by  sqrt(n) in order to resemble  a typical matrix of  a 2D piecewise linear FEM discretization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/ExtendableSparse.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example/">« Examples &amp; Benchmarks</a><a class="docs-footer-nextpage" href="../iter/">Factorizations &amp; Preconditioners »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 5 January 2023 22:58">Thursday 5 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
