var documenterSearchIndex = {"docs":
[{"location":"changes/#Changes","page":"Changes","title":"Changes","text":"","category":"section"},{"location":"changes/#v0.5,-April-10,-2021","page":"Changes","title":"v0.5, April 10, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Introduce lu/lu! , factorize/factorize!, unifying LU factorizations and preconditioners\nInterface packages: Pardiso, AlgebraicMultigrid, IncompleteLU via Requires.jl","category":"page"},{"location":"changes/#v0.4,-March-2021","page":"Changes","title":"v0.4, March 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix handling of Symmetrix matrices\nrawupdateindex does not check for entering zeros\nCompare with COO method\nBenchmarks in documentation","category":"page"},{"location":"changes/#v0.3.7,-March-20,-2021","page":"Changes","title":"v0.3.7, March 20, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Added parallel jacobi preconditioner (thanks, @jkr)\nFixes ldiv\nAdded simple iterative solver\nDocumentation update\nTests for precondioners, fdrand","category":"page"},{"location":"changes/#v0.3.0,-April-10,-2020","page":"Changes","title":"v0.3.0, April 10, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Don't create new entry if the value to be assigned is zero, making things consistent with SparseMatrixCSC and ForwardDiff  as suggested by @MaximilianJHuber","category":"page"},{"location":"changes/#v0.2.5,-Jan-26,-2020","page":"Changes","title":"v0.2.5, Jan 26, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"fixed allocations in  Base.+\nadded updateindex! method \nprovide fdrand and fdrand! matrix constructors\nautomatic benchmarks in examples","category":"page"},{"location":"changes/#v0.2.4,-Jan-19,-2020","page":"Changes","title":"v0.2.4, Jan 19, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Allow preconditioner creation directly from CSC Matrix\nRename AbstractPreconditioner to AbstractExtendablePreconditioner","category":"page"},{"location":"changes/#v0.2.3,-Jan-15,-2020","page":"Changes","title":"v0.2.3, Jan 15, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Started to introduce preconditioners (undocumented)","category":"page"},{"location":"changes/#v0.2.3,-Jan-8,-2020","page":"Changes","title":"v0.2.3, Jan 8, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"added norm, cond, opnorm methods\nresize! instead of push! when adding entries should trigger less allocation operations","category":"page"},{"location":"changes/#v0.2.2.-Dec-23,-2019","page":"Changes","title":"v0.2.2. Dec 23, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"What used to be _splice  is now + and allows now real addition (resulting in a CSC matrix)\nAdded constructors of LNK matrix from CSC matrix and vice versa\nreorganized tests","category":"page"},{"location":"changes/#v0.2.1-Dec-22,-2019","page":"Changes","title":"v0.2.1 Dec 22, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Tried to track down the source from which I learned the linked list based struct in order to document this. Ended up with SPARSEKIT of Y.Saad, however I believe this  already was in SPARSEPAK by Chu,George,Liu.\nInternal rename of SparseMatrixExtension to SparseMatrixLNK. ","category":"page"},{"location":"changes/#v0.2-Dec-21,-2019","page":"Changes","title":"v0.2 Dec 21, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"more interface methods delegating to csc, in particular mul! and ldiv!\nlazy creation of extendable part: don't create idle memory\nnicer constructors","category":"page"},{"location":"changes/#V0.1,-July-2019","page":"Changes","title":"V0.1, July 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Initial release","category":"page"},{"location":"iter/#Factorizations-and-Preconditioners","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"","category":"section"},{"location":"iter/#Factorizations","page":"Factorizations & Preconditioners","title":"Factorizations","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"In this package, preconditioners and LU factorizations are subcategories are both seen as complete or approximate factorizations. Correspondingly there is a common API for their creation.","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Factorizations from these package know the matrices which have been factorized.","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Modules = [ExtendableSparse]\nPages = [\"factorizations.jl\"]","category":"page"},{"location":"iter/#ExtendableSparse.default_options","page":"Factorizations & Preconditioners","title":"ExtendableSparse.default_options","text":"const default_options\n\nDefault options for various factorizations:\n\nkind: umfpack\nensurelu: false\ndroptol: 0.001\n\n\n\n\n\n","category":"constant"},{"location":"iter/#ExtendableSparse.AbstractExtendableSparseFactorization","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AbstractExtendableSparseFactorization","text":"abstract type AbstractExtendableSparseFactorization{Tv, Ti}\n\nAbstract type for a factorization   with ExtandableSparseMatrix. \n\nAny such preconditioner should have the following fields\n\n  A\n  fact\n  phash\n\nand  methods\n\n  factorize(A; kwargs)\n  ldiv!(u, precon,v)\n  ldiv!(precon,v)\n  issolver(precon)\n  update!(precon)\n  factorize!(precon,A; kwargs)\n\nThe idea is that, depending if the matrix pattern has changed,    different steps are needed to update the preconditioner.\n\nMoreover, they have the ExtendableSparseMatrix as a field, ensuring    consistency after construction.\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.AbstractExtendableSparseLU","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AbstractExtendableSparseLU","text":"abstract type AbstractExtendableSparseLU{Tv, Ti} <: ExtendableSparse.AbstractExtendableSparseFactorization{Tv, Ti}\n\nAbstract subtype for (full) LU factorizations\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.AbstractExtendableSparsePreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AbstractExtendableSparsePreconditioner","text":"abstract type AbstractExtendableSparsePreconditioner{Tv, Ti} <: ExtendableSparse.AbstractExtendableSparseFactorization{Tv, Ti}\n\nAbstract subtype for preconditioners\n\n\n\n\n\n","category":"type"},{"location":"iter/#Base.:\\-Tuple{ExtendableSparse.AbstractExtendableSparseLU, AbstractVector{T} where T}","page":"Factorizations & Preconditioners","title":"Base.:\\","text":" lufact\rhs\n\nSolve  LU factorization problem.\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.factorize!-Tuple{Nothing, ExtendableSparseMatrix}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.factorize!","text":"factorize!(factorization_or_nothing, matrix; kwargs...)\n\nUpdate factorization, possibly reusing information from the current state. This method is aware of pattern changes.\n\nIf nothing is passed as first parameter, factorize is called.\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.factorize-Tuple{ExtendableSparseMatrix}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.factorize","text":"factorize(matrix)\nfactorize(matrix; kind=:umfpack)\nfactorize(matrix; kind=:default)\n\nDefault Julia LU factorization based on SuiteSparse.UMFPACK.\n\nfactorize(matrix; kind=:cholmod)\nfactorize(matrix; kind=:cholesky)\n\nDefault Cholesky factorization via SuiteSparse.CHOLMOD\n\nfactorize(matrix; kind=:pardiso)\nfactorize(matrix; kind=:mklpardiso)\n\nLU factorization based on pardiso. For using this, you need to issue using Pardiso. :pardiso uses the  solver from pardiso-project.org, while :mklpardiso uses the early 2000's fork in Intel's MKL library.\n\nfactorize(matrix; kind=:ilu0)\n\nCreate the ILU0Preconditioner from this package.\n\nfactorize(matrix; kind=:jacobi)\n\nCreate the JacobiPreconditioner from this package.\n\nfactorize(matrix; kind=:pjacobi)\n\nCreate the ParallelJacobiPreconditioner from this package.\n\nfactorize(matrix; kind=:ilut, droptol=1.0e-3)\n\nCreate the ILUTPreconditioner wrapping the one  from IncompleteLU.jl For using this, you need to issue using IncompleteLU\n\nfactorize(matrix; kind=:rsamg)\n\nCreate the  AMGPreconditioner wrapping the Ruge-StÃ¼ben AMG preconditioner from AlgebraicMultigrid.jl\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.issolver-Tuple{ExtendableSparse.AbstractExtendableSparseLU}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.issolver","text":"issolver(factorization)\n\nDetermine if factorization is a solver or not\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.options-Tuple{}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.options","text":"options(;kwargs...)\n\nSet default options and blend them with kwargs\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.update!-Tuple{ExtendableSparse.AbstractExtendableSparseFactorization}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.update!","text":"update!(factorization)\n\nUpdate factorization after matrix update.\n\n\n\n\n\n","category":"method"},{"location":"iter/#LinearAlgebra.ldiv!-Tuple{Any, ExtendableSparse.AbstractExtendableSparseFactorization, Any}","page":"Factorizations & Preconditioners","title":"LinearAlgebra.ldiv!","text":"ldiv!(u,factorization,v)\nldiv!(factorization,v)\n\nSolve factorization.\n\n\n\n\n\n","category":"method"},{"location":"iter/#LinearAlgebra.lu!-Tuple{Nothing, ExtendableSparseMatrix}","page":"Factorizations & Preconditioners","title":"LinearAlgebra.lu!","text":"lu!(factorization_or_nothing, matrix; kwargs...)\n\nUpdate LU factorization, possibly reusing information from the current state. This method is aware of pattern changes.\n\nIf nothing is passed as first parameter, factorize is called.\n\n\n\n\n\n","category":"method"},{"location":"iter/#LinearAlgebra.lu-Tuple{ExtendableSparseMatrix}","page":"Factorizations & Preconditioners","title":"LinearAlgebra.lu","text":"lu(matrix)\nlu(matrix,kind=:pardiso)\nlu(matrix,kind=:mklpardiso)\n\nWrapper for factorize restricted to lu factorizations.\n\n\n\n\n\n","category":"method"},{"location":"iter/#LU-Factorizations","page":"Factorizations & Preconditioners","title":"LU Factorizations","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Modules = [ExtendableSparse]\nPages = [\"umfpack_lu.jl\", \"pardiso_lu.jl\"]","category":"page"},{"location":"iter/#ExtendableSparse.ExtendableSparseUmfpackLU","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ExtendableSparseUmfpackLU","text":"mutable struct ExtendableSparseUmfpackLU{Tv, Ti} <: ExtendableSparse.AbstractExtendableSparseLU{Tv, Ti}\n\nDefault Julia LU Factorization based on umfpack.\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.ExtendableSparseUmfpackLU-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ExtendableSparseUmfpackLU","text":"ExtendableSparseUmfpackLU(A)\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.PardisoLU","page":"Factorizations & Preconditioners","title":"ExtendableSparse.PardisoLU","text":"mutable struct PardisoLU{Tv, Ti} <: ExtendableSparse.AbstractExtendableSparseLU{Tv, Ti}\n\nLU Factorization\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.PardisoLU-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.PardisoLU","text":"PardisoLU(A; ps=Pardiso.MKLPardisoSolver)\n\n\n\n\n\n","category":"method"},{"location":"iter/#Preconditioners","page":"Factorizations & Preconditioners","title":"Preconditioners","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Modules = [ExtendableSparse]\nPages = [\"jacobi.jl\",\"ilu0.jl\",\"parallel_jacobi.jl\",\"ilut.jl\",\"amg.jl\"]","category":"page"},{"location":"iter/#ExtendableSparse.JacobiPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.JacobiPreconditioner","text":"mutable struct JacobiPreconditioner{Tv, Ti} <: ExtendableSparse.AbstractExtendableSparsePreconditioner{Tv, Ti}\n\nJacobi preconditoner\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.JacobiPreconditioner-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.JacobiPreconditioner","text":"JacobiPreconditioner(A)\nJacobiPreconditioner(cscmatrix)\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.ParallelJacobiPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ParallelJacobiPreconditioner","text":"mutable struct ParallelJacobiPreconditioner{Tv, Ti} <: ExtendableSparse.AbstractExtendableSparsePreconditioner{Tv, Ti}\n\nParallel Jacobi preconditioner\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.ParallelJacobiPreconditioner-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ParallelJacobiPreconditioner","text":"ParallelJacobiPreconditioner(A)\nParallelJacobiPreconditioner(cscmatrix)\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.ILU0Preconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ILU0Preconditioner","text":"mutable struct ILU0Preconditioner{Tv, Ti} <: ExtendableSparse.AbstractExtendableSparsePreconditioner{Tv, Ti}\n\nILU(0) Preconditioner\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.ILU0Preconditioner-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ILU0Preconditioner","text":"ILU0Preconditioner(extsparse)\nILU0Preconditioner(cscmatrix)\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.ILUTPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ILUTPreconditioner","text":"mutable struct ILUTPreconditioner{Tv, Ti} <: ExtendableSparse.AbstractExtendableSparsePreconditioner{Tv, Ti}\n\nILU(T) preconditioner\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.ILUTPreconditioner-Tuple{ExtendableSparseMatrix}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ILUTPreconditioner","text":"ILUTPreconditioner(matrix; droptol=1.0e-3)\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.AMGPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AMGPreconditioner","text":"mutable struct AMGPreconditioner{Tv, Ti} <: ExtendableSparse.AbstractExtendableSparsePreconditioner{Tv, Ti}\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.AMGPreconditioner-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AMGPreconditioner","text":"AMGPreconditioner(extmatrix)\n\n\n\n\n\n","category":"method"},{"location":"internal/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal/#Linked-List-Sparse-Matrix-format","page":"Internal API","title":"Linked List Sparse Matrix format","text":"","category":"section"},{"location":"internal/","page":"Internal API","title":"Internal API","text":"Modules = [ExtendableSparse]\nPages = [\"sparsematrixlnk.jl\"]","category":"page"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"mutable struct SparseMatrixLNK{Tv, Ti<:Integer} <: SparseArrays.AbstractSparseArray{Tv, Ti<:Integer, 2}\n\nStruct to hold sparse matrix in the linked list format.\n\nModeled after the linked list sparse matrix format described in  the  whitepaper and the  SPARSEKIT2 source code by Y. Saad. He writes \"This is one of the oldest data structures used for sparse matrix computations.\"\n\nThe relevant source formats.f is also available in the debian/science gitlab.\n\nThe advantage of the linked list structure is the fact that upon insertion of a new entry, the arrays describing the structure can grow at their respective ends and can be conveniently updated via push!.  No copying of existing data is necessary.\n\nm::Integer\nNumber of rows\n\nn::Integer\nNumber of columns\n\nnnz::Integer\nNumber of nonzeros\n\nnentries::Integer\nLength of arrays\n\ncolptr::Vector{Ti} where Ti<:Integer\nLinked list of column entries. Initial length is n, it grows with each new entry.\ncolptr[index] contains the next index in the list or zero, in the later case terminating the list which starts at index 1<=j<=n for each column j.\n\nrowval::Vector{Ti} where Ti<:Integer\nRow numbers. For each index it contains the zero (initial state) or the row numbers corresponding to the column entry list in colptr.\nInitial length is n, it grows with each new entry.\n\nnzval::Vector{Tv} where Tv\nNonzero entry values correspondin to each pair (colptr[index],rowval[index])\nInitial length is n,  it grows with each new entry.\n\n\n\n\n\n","category":"type"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti<:Integer}","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"Constructor from SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Any, Any}} where {Tv, Ti<:Integer}","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"SparseMatrixLNK(m, n)\n\n\nConstructor of empty matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Type{Tv}, Type{Ti}, Any, Any}} where {Tv, Ti<:Integer}","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"SparseMatrixLNK(valuetype, indextype, m, n)\n\n\nConstructor of empty matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{Tv}, Tuple{Any, Any}} where Tv","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"SparseMatrixLNK(m, n)\n\n\nConstructor of empty matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{Tv}, Tuple{Type{Tv}, Any, Any}} where Tv","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"SparseMatrixLNK(valuetype, m, n)\n\n\nConstructor of empty matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SparseArrays.SparseMatrixCSC-Tuple{SparseMatrixLNK}","page":"Internal API","title":"SparseArrays.SparseMatrixCSC","text":"SparseMatrixCSC(lnk)\n\n\nConstructor from SparseMatrixLNK.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.:+-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv, Ti}, SparseArrays.SparseMatrixCSC}} where {Tv, Ti<:Integer}","page":"Internal API","title":"Base.:+","text":"+(lnk, csc)\n\n\nAdd SparseMatrixCSC matrix and SparseMatrixLNK  lnk, returning a SparseMatrixCSC\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.getindex-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv, Ti}, Any, Any}} where {Tv, Ti}","page":"Internal API","title":"Base.getindex","text":"getindex(lnk, i, j)\n\n\nReturn value stored for entry or zero if not found\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.setindex!-Tuple{SparseMatrixLNK, Any, Any, Any}","page":"Internal API","title":"Base.setindex!","text":"setindex!(lnk, v, i, j)\n\n\nUpdate value of existing entry, otherwise extend matrix if v is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.size-Tuple{SparseMatrixLNK}","page":"Internal API","title":"Base.size","text":"size(lnk)\n\n\nReturn tuple containing size of the matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.flush!-Union{Tuple{SparseMatrixLNK{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Internal API","title":"ExtendableSparse.flush!","text":"Dummy flush! method for SparseMatrixLNK. Just used in test methods\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.rawupdateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti}","page":"Internal API","title":"ExtendableSparse.rawupdateindex!","text":"rawupdateindex!(lnk, op, v, i, j)\n\n\nUpdate element of the matrix  with operation op.  It assumes that op(0,0)==0. If v is zero a new entry is created nevertheless.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti}","page":"Internal API","title":"ExtendableSparse.updateindex!","text":"Update element of the matrix  with operation op.  It assumes that op(0,0)==0. If v is zero, no new  entry is created.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SparseArrays.nnz-Tuple{SparseMatrixLNK}","page":"Internal API","title":"SparseArrays.nnz","text":"nnz(lnk)\n\n\nReturn number of nonzero entries.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Some-methods-for-SparseMatrixCSC","page":"Internal API","title":"Some methods for SparseMatrixCSC","text":"","category":"section"},{"location":"internal/","page":"Internal API","title":"Internal API","text":"Modules = [ExtendableSparse]\nPages = [\"sparsematrixcsc.jl\"]","category":"page"},{"location":"internal/#ExtendableSparse.findindex-Union{Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T, Ti} where Ti<:Integer, Any, Any}} where T","page":"Internal API","title":"ExtendableSparse.findindex","text":"findindex(csc, i, j)\n\n\nReturn index corresponding to entry [i,j] in the array of nonzeros, if the entry exists, otherwise, return 0.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.flush!-Tuple{SparseArrays.SparseMatrixCSC}","page":"Internal API","title":"ExtendableSparse.flush!","text":"flush!(csc)\n\n\nTrival flush! method for allowing to run the code with both ExtendableSparseMatrix and SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.phash-Tuple{SparseArrays.SparseMatrixCSC}","page":"Internal API","title":"ExtendableSparse.phash","text":"phash(csc)\n\n\nHash of csc matrix pattern. \n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti<:Integer}","page":"Internal API","title":"ExtendableSparse.updateindex!","text":"updateindex!(csc, op, v, i, j)\n\n\nUpdate element of the matrix  with operation op whithout introducing new nonzero elements.\n\nThis can replace the following code and save one index search during acces:\n\nusing ExtendableSparse # hide\nusing SparseArrays # hide\nA=spzeros(3,3)\nA[1,2]+=0.1\nA\n\nusing ExtendableSparse # hide\nusing SparseArrays # hide\nA=spzeros(3,3)\nupdateindex!(A,+,0.1,1,2)\nA\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Sparse-matrix-handling","page":"Sparse matrix handling","title":"Sparse matrix handling","text":"","category":"section"},{"location":"extsparse/#Matrix-creation-and-update-API","page":"Sparse matrix handling","title":"Matrix creation and update API","text":"","category":"section"},{"location":"extsparse/","page":"Sparse matrix handling","title":"Sparse matrix handling","text":"Modules = [ExtendableSparse]\nPages = [\"extendable.jl\"]","category":"page"},{"location":"extsparse/#ExtendableSparse.ExtendableSparseMatrix","page":"Sparse matrix handling","title":"ExtendableSparse.ExtendableSparseMatrix","text":"mutable struct ExtendableSparseMatrix{Tv, Ti<:Integer} <: SparseArrays.AbstractSparseArray{Tv, Ti<:Integer, 2}\n\nExtendable sparse matrix. A nonzero  entry of this matrix is contained either in cscmatrix, or in lnkmatrix, never in both.\n\ncscmatrix::SparseArrays.SparseMatrixCSC\nFinal matrix data\n\nlnkmatrix::Union{Nothing, SparseMatrixLNK{Tv, Ti}} where {Tv, Ti<:Integer}\nLinked list structure holding data of extension\n\nphash::UInt64\nPattern hash\n\n\n\n\n\n","category":"type"},{"location":"extsparse/#ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti<:Integer}","page":"Sparse matrix handling","title":"ExtendableSparse.ExtendableSparseMatrix","text":"Create ExtendableSparseMatrix from SparseMatrixCSC\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.ExtendableSparseMatrix-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Any, Any}} where {Tv, Ti<:Integer}","page":"Sparse matrix handling","title":"ExtendableSparse.ExtendableSparseMatrix","text":"ExtendableSparseMatrix(Tv,Ti,m,n)\nExtendableSparseMatrix(Tv,m,n)\nExtendableSparseMatrix(m,n)\n\nCreate empty ExtendableSparseMatrix. This is equivalent to spzeros(m,n) for SparseMartrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:+-Tuple{ExtendableSparseMatrix, SparseArrays.SparseMatrixCSC}","page":"Sparse matrix handling","title":"Base.:+","text":"+(ext, csc)\n\n\nAdd SparseMatrixCSC matrix and ExtendableSparseMatrix  ext.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:--Tuple{ExtendableSparseMatrix, SparseArrays.SparseMatrixCSC}","page":"Sparse matrix handling","title":"Base.:-","text":"-(ext, csc)\n\n\nSubtract  SparseMatrixCSC matrix from  ExtendableSparseMatrix  ext.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:--Tuple{SparseArrays.SparseMatrixCSC, ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"Base.:-","text":"-(csc, ext)\n\n\nSubtract  ExtendableSparseMatrix  ext from  SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:\\-Tuple{ExtendableSparseMatrix, AbstractVecOrMat{T} where T}","page":"Sparse matrix handling","title":"Base.:\\","text":"\\(ext, B)\n\n\n\\ for extmatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{LinearAlgebra.Hermitian{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVecOrMat{T} where T}} where {Tm, Ti}","page":"Sparse matrix handling","title":"Base.:\\","text":"\\(symm_ext, B)\n\n\n\\ for Hermitian{ExtendableSparse}\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{LinearAlgebra.Symmetric{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVecOrMat{T} where T}} where {Tm, Ti}","page":"Sparse matrix handling","title":"Base.:\\","text":"\\(symm_ext, B)\n\n\n\\ for Symmetric{ExtendableSparse}\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.getindex-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any}} where {Tv, Ti<:Integer}","page":"Sparse matrix handling","title":"Base.getindex","text":"getindex(ext, i, j)\n\n\nFind index in CSC matrix and return value, if it exists. Otherwise, return value from extension.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.setindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any}} where {Tv, Ti}","page":"Sparse matrix handling","title":"Base.setindex!","text":"setindex!(ext, v, i, j)\n\n\nFind index in CSC matrix and set value if it exists. Otherwise, set index in extension if v is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"Base.show","text":"show(io, _, ext)\n\n\nShow matrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.similar-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Sparse matrix handling","title":"Base.similar","text":"Create similar but emtpy extendableSparseMatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.size-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"Base.size","text":"size(ext)\n\n\nSize of ExtendableSparseMatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.colptrs-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"ExtendableSparse.colptrs","text":"colptrs(ext)\n\n\nflush! and return colptr of  in ext.cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"ExtendableSparse.flush!","text":"flush!(ext)\n\n\nIf there are new entries in extension, create new CSC matrix by adding the cscmatrix and linked list matrix and reset the linked list based extension.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.rawupdateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti<:Integer}","page":"Sparse matrix handling","title":"ExtendableSparse.rawupdateindex!","text":"rawupdateindex!(ext, op, v, i, j)\n\n\nLike updateindex! but without  checking if v is zero.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any, Any, Any, Any}} where {Tv, Ti<:Integer}","page":"Sparse matrix handling","title":"ExtendableSparse.updateindex!","text":"Update element of the matrix  with operation op. This can replace the following code and save one index search during acces:\n\nusing ExtendableSparse # hide\nA=ExtendableSparseMatrix(3,3)\nA[1,2]+=0.1\nA\n\nusing ExtendableSparse # hide\n\nA=ExtendableSparseMatrix(3,3)\nupdateindex!(A,+,0.1,1,2)\nA\n\nIf v is zero, no new entry is created.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#LinearAlgebra.cond","page":"Sparse matrix handling","title":"LinearAlgebra.cond","text":"cond(A)\ncond(A, p)\n\n\nflush! and calculate cond from cscmatrix\n\n\n\n\n\n","category":"function"},{"location":"extsparse/#LinearAlgebra.issymmetric-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"LinearAlgebra.issymmetric","text":"issymmetric(A)\n\n\nflush! and check for symmetry of cscmatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#LinearAlgebra.ldiv!-Tuple{Any, ExtendableSparseMatrix, Any}","page":"Sparse matrix handling","title":"LinearAlgebra.ldiv!","text":"ldiv!(r, ext, x)\n\n\nflush! and ldiv with ext.cscmatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#LinearAlgebra.mul!-Tuple{Any, ExtendableSparseMatrix, Any}","page":"Sparse matrix handling","title":"LinearAlgebra.mul!","text":"mul!(r, ext, x)\n\n\nflush! and multiply with ext.cscmatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#LinearAlgebra.norm","page":"Sparse matrix handling","title":"LinearAlgebra.norm","text":"norm(A)\nnorm(A, p)\n\n\nflush! and calculate norm from cscmatrix\n\n\n\n\n\n","category":"function"},{"location":"extsparse/#LinearAlgebra.opnorm","page":"Sparse matrix handling","title":"LinearAlgebra.opnorm","text":"opnorm(A)\nopnorm(A, p)\n\n\nflush! and calculate opnorm from cscmatrix\n\n\n\n\n\n","category":"function"},{"location":"extsparse/#SparseArrays.dropzeros!-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.dropzeros!","text":"dropzeros!(ext)\n\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.findnz-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.findnz","text":"findnz(ext)\n\n\nflush! and return findnz(ext.cscmatrix).\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.nnz-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.nnz","text":"nnz(ext)\n\n\nflush! and return number of nonzeros in ext.cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.nonzeros-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.nonzeros","text":"nonzeros(ext)\n\n\nflush! and return nonzeros in ext.cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.rowvals-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.rowvals","text":"rowvals(ext)\n\n\nflush! and return rowvals in ext.cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Test-matrix-creation","page":"Sparse matrix handling","title":"Test matrix creation","text":"","category":"section"},{"location":"extsparse/","page":"Sparse matrix handling","title":"Sparse matrix handling","text":"Modules = [ExtendableSparse]\nPages = [\"sprand.jl\"]","category":"page"},{"location":"extsparse/#ExtendableSparse.fdrand!-Union{Tuple{T}, Tuple{T, Any, Any, Any}} where T<:(AbstractMatrix{T} where T)","page":"Sparse matrix handling","title":"ExtendableSparse.fdrand!","text":"fdrand!(A, nx, ny, nz; update, rand)\n\n\nAfter setting  all nonzero entries  to zero, fill resp.  update matrix with finite  difference discretization data  on a unit  hypercube. See fdrand for documentation of the parameters.\n\nIt is required that size(A)==(N,N) where N=nx*ny*nz\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.fdrand-Tuple{Any, Any, Any}","page":"Sparse matrix handling","title":"ExtendableSparse.fdrand","text":"fdrand(nx, ny, nz; matrixtype, update, rand)\n\n\nCreate matrix  for a mock  finite difference operator for  a diffusion problem with random coefficients on a unit hypercube Omegasubsetmathbb R^d. with d=1 if  nx>1 && ny==1 && nz==1, d=2 if  nx>1 && ny>1 && nz==1 and d=3 if  nx>1 && ny>1 && nz>1 .\n\n    beginalign*\n             -nabla a nabla u = f  textin  Omega  \n    anabla ucdot vec n + bu =g  texton  partialOmega\n    endalign*\n\nThe matrix is irreducibly diagonally dominant, has positive main diagonal entries  and nonpositive off-diagonal entries, hence it has the M-Property. Therefore, its inverse will be a dense matrix with positive entries.  Moreover it is symmmetric, and  positive definite, and the spectral radius of the  Jacobi iteration matrix ho(I-D(A)^-1A)1 .\n\nParameters+ default values:\n\nParameter + default vale Description\nnx Number of unknowns in x direction\nny Number of unknowns in y direction\nnz Number of unknowns in z direction\nmatrixtype = SparseMatrixCSC Matrix type\nupdate = (A,v,i,j)-> A[i,j]+=v Element update function\nrand =()-> rand() Random number generator\n\nThe sparsity structure is fixed to an orthogonal grid, resulting in a 3, 5 or 7 diagonal matrix depending on dimension. The entries are random unless e.g.  rand=()->1 is passed as random number generator. Tested for Matrix, SparseMatrixCSC,  ExtendableSparseMatrix, SparseMatrixLNK and :COO\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.sprand!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.AbstractSparseMatrix{Tv, Ti}, Int64}} where {Tv, Ti}","page":"Sparse matrix handling","title":"ExtendableSparse.sprand!","text":"sprand!(A, xnnz)\n\n\nFill empty sparse matrix A with random nonzero elements from interval [1,2] using incremental assembly.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.sprand_sdd!-Union{Tuple{SparseArrays.AbstractSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Sparse matrix handling","title":"ExtendableSparse.sprand_sdd!","text":"Fill sparse matrix  with random entries such that  it becomes strictly diagonally  dominant  and  thus  invertible and  has  a  fixed  number nnzrow (default: 4) of nonzeros in its rows. The matrix bandwidth is bounded by  sqrt(n) in order to resemble  a typical matrix of  a 2D piecewise linear FEM discretization.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"example/#Examples-and-Benchmarks","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"","category":"section"},{"location":"example/#Matrix-creation-example","page":"Examples & Benchmarks","title":"Matrix creation example","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"An ExtendableSparseMatrix can serve as a drop-in replacement for SparseMatrixCSC, albeit with faster assembly during the buildup phase when using index based access.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Let us define a simple assembly loop","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nfunction assemble(A)\n    n=size(A,1)\n    for i=1:n-1\n        A[i+1,i]+=-1\n        A[i,i+1]+=-1\n        A[i,i]+=1\n        A[i+1,i+1]+=1\n    end\nend;","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Measure the time (in seconds) for assembling a SparseMatrixCSC:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"t_csc= @belapsed begin\n                   A=spzeros(10_000,10_000)\n                   assemble(A)\n                 end","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"An ExtendableSparseMatrix can be used as a drop-in replacement. However, before any other use, this needs an internal structure rebuild which is invoked by the flush! method.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"t_ext=@belapsed  begin \n                   A=ExtendableSparseMatrix(10_000,10_000)\n                   assemble(A)\n                   flush!(A)\n                 end","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"All  specialized methods of linear algebra functions (e.g. \\) for ExtendableSparseMatrix  call flush! before proceeding.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"The overall time gain from using ExtendableSparse is:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"t_ext/t_csc","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"The reason for this situation is that the SparseMatrixCSC struct just contains the data for storing the matrix in the compressed column format. Inserting a new entry in this storage scheme is connected with serious bookkeeping and shifts of large portions of array content.  ","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Julia provides the sparse method which  uses an intermediate  storage of  the data in  two index arrays and a value array, the so called coordinate (or COO) format:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"function assemble_coo(n)\n    I=zeros(Int64,0)\n    J=zeros(Int64,0)\n    V=zeros(0)\n    function update(i,j,v)\n        push!(I,i)\n        push!(J,j)\n        push!(V,v)\n    end\n    for i=1:n-1\n        update(i+1,i,-1)\n        update(i,i+1,-1)\n        update(i,i,1)\n        update(i+1,i+1,1)\n    end\n    sparse(I,J,V)\nend;\n\nt_coo=@belapsed assemble_coo(10_000)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"While more convenient to use, the assembly based on ExtendableSparseMatrix is only slightly slower:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"t_ext/t_coo","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Below one finds a more elaborate discussion for a quasi-3D problem.","category":"page"},{"location":"example/#Matrix-creation-benchmark","page":"Examples & Benchmarks","title":"Matrix creation benchmark","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"The method fdrand  creates a matrix similar to the discretization matrix of a Poisson equation on a d-dimensional cube. The approach is similar to that of a typical finite element code: calculate a local stiffness matrix and assemble it into the global one.","category":"page"},{"location":"example/#Benchmark-for-[ExtendableSparseMatrix](@ref)","page":"Examples & Benchmarks","title":"Benchmark for ExtendableSparseMatrix","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"The code uses the index access API for the creation of the matrix, inserting elements via A[i,j]+=v, using an intermediate linked list structure which upon return ist flushed into a SparseMatrixCSC structure.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"@belapsed fdrand(30,30,30, matrixtype=ExtendableSparseMatrix)","category":"page"},{"location":"example/#Benchmark-for-SparseMatrixCSC","page":"Examples & Benchmarks","title":"Benchmark for  SparseMatrixCSC","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Here, for comparison we use  a SparseMatrixCSC created with spzeros and insert entries via A[i,j]+=v.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\n@belapsed fdrand(30,30,30, matrixtype=SparseMatrixCSC)","category":"page"},{"location":"example/#Benchmark-for-intermediate-coordinate-format","page":"Examples & Benchmarks","title":"Benchmark for  intermediate coordinate format","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"A SparseMatrixCSC is created by accumulating data into arrays I,J,A and calling sparse(I,J,A)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\n@belapsed fdrand(30,30,30, matrixtype=:COO)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"This is nearly on par with matrix creation via ExtendableSparseMatrix, but the later can be made faster:","category":"page"},{"location":"example/#Benchmark-for-ExtendableSparseMatrix-with-updateindex","page":"Examples & Benchmarks","title":"Benchmark  for ExtendableSparseMatrix with updateindex","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Here, we use  a ExtendableSparseMatrix created withspzerosand insert entries viaupdateindex(A,+,v,i,j)`, see the discussion below.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\n@belapsed fdrand(30,30,30, \n    matrixtype=ExtendableSparseMatrix,\n    update=(A,v,i,j)-> updateindex!(A,+,v,i,j))","category":"page"},{"location":"example/#Matrix-update-benchmark","page":"Examples & Benchmarks","title":"Matrix update benchmark","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"For repeated calculations on the same sparsity structure (e.g. for time dependent problems or Newton iterations) it is convenient to skip all but the first creation steps and to just replace the values in the matrix after setting the elements of the nzval  vector to zero. Typically in finite element and finite volume methods this step updates matrix entries (most of them several times) by adding values. In this case, the current indexing interface of Julia requires to access the matrix twice:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using SparseArrays     # hide\nA=spzeros(3,3)\nMeta.@lower A[1,2]+=3","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"For sparse matrices this requires to perform the index search in the structure twice. The packages provides the method updateindex! for both SparseMatrixCSC and  for ExtendableSparse which allows to update a matrix element with just one index search.","category":"page"},{"location":"example/#Benchmark-for-SparseMatrixCSC-2","page":"Examples & Benchmarks","title":"Benchmark for SparseMatrixCSC","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nA=fdrand(30,30,30, matrixtype=SparseMatrixCSC)\n@belapsed fdrand!(A,30,30,30, \n                   update=(A,v,i,j)-> A[i,j]+=v)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nA=fdrand(30,30,30, matrixtype=SparseMatrixCSC)\n@belapsed fdrand!(A,30,30,30, \n                   update=(A,v,i,j)-> updateindex!(A,+,v,i,j))","category":"page"},{"location":"example/#Benchmark-for-ExtendableSparseMatrix","page":"Examples & Benchmarks","title":"Benchmark for ExtendableSparseMatrix","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nA=fdrand(30,30,30, matrixtype=ExtendableSparseMatrix)\n@belapsed fdrand!(A,30,30,30, \n                   update=(A,v,i,j)-> A[i,j]+=v)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nA=fdrand(30,30,30, matrixtype=ExtendableSparseMatrix)\n@belapsed fdrand!(A,30,30,30, \n                   update=(A,v,i,j)-> updateindex!(A,+,v,i,j))","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Note that the update process for ExtendableSparse may be slightly slower than for SparseMatrixCSC due to the overhead which comes from checking the presence of new entries.","category":"page"}]
}
