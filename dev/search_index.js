var documenterSearchIndex = {"docs":
[{"location":"changes/#Changes","page":"Changes","title":"Changes","text":"","category":"section"},{"location":"changes/#v1.3,-Jan-16,-2024","page":"Changes","title":"v1.3, Jan 16, 2024","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"AMGCLWrap extension, renamed AMGPreconditioner to RS_AMGPreconditioner\nmuted Pardiso","category":"page"},{"location":"changes/#v1.2,-August-5,-2023","page":"Changes","title":"v1.2, August 5, 2023","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Introduced 1.9 extensions for Pardiso, AlgebraicMultigrid, IncompleteLU","category":"page"},{"location":"changes/#v1.1,-May-3,-2023","page":"Changes","title":"v1.1, May 3, 2023","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"AbstractFactorization and subtypes are now without element and index type information. They wrap more concretely typed info. This shall allow to construct a preconditioner without knowing matrix and element type.\nFirst steps to block preconditioning\nsrc directory restructured","category":"page"},{"location":"changes/#v1.0.1,-Jan-22,-2023","page":"Changes","title":"v1.0.1, Jan 22, 2023","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"support of AbstractSparseMatrixCSC interface\nreplace SparseArrays.sparse by SparseArrays.SparseMatrixCSC","category":"page"},{"location":"changes/#v0.9.6,-Jan-22,-2023","page":"Changes","title":"v0.9.6, Jan 22, 2023","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"support for LinearSolve.jl","category":"page"},{"location":"changes/#v0.9.1-...-v0.9.5,-Jan-5,-2023","page":"Changes","title":"v0.9.1 ... v0.9.5, Jan 5, 2023","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"update interface with Sparspak\nAddition, multiplication etc. for ExtendableSparse\nILUZero.jl as dependency for ILUZeroPreconditioner\nfix ILU0Preconditioner backsubstitution for unsymmetric matrices\nAdd LinearAlgebra.lu etc. for ExtendableSparse","category":"page"},{"location":"changes/#v0.9,-Sept-28,-2022","page":"Changes","title":"v0.9, Sept 28, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"\\ support for general number types and non-GPL system images based on Sparspak.jl 0.3.0","category":"page"},{"location":"changes/#v0.8,-Sept-1,-2022","page":"Changes","title":"v0.8, Sept 1, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Remove LinearSolve compatibility in favor of (future) interfacing via AbstractSparseMatrixCSC\nAdd Sparspak LU factorization\nAdd handling of GPL free sysimage build","category":"page"},{"location":"changes/#v0.7,-August-19,-2022","page":"Changes","title":"v0.7, August 19, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Require Julia 1.6\nfirst steps to compatibility with LinearSolve.jl","category":"page"},{"location":"changes/#v0.6,-April-20,-2021","page":"Changes","title":"v0.6, April 20, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"use type parameters to describe factorizations","category":"page"},{"location":"changes/#v0.5,-April-10,-2021","page":"Changes","title":"v0.5, April 10, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Introduce lu/lu! , factorize/factorize!, unifying LU factorizations and preconditioners\nInterface packages: Pardiso, AlgebraicMultigrid, IncompleteLU via Requires.jl","category":"page"},{"location":"changes/#v0.4,-March-2021","page":"Changes","title":"v0.4, March 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix handling of Symmetrix matrices\nrawupdateindex does not check for entering zeros\nCompare with COO method\nBenchmarks in documentation","category":"page"},{"location":"changes/#v0.3.7,-March-20,-2021","page":"Changes","title":"v0.3.7, March 20, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Added parallel jacobi preconditioner (thanks, @jkr)\nFixes ldiv\nAdded simple iterative solver\nDocumentation update\nTests for precondioners, fdrand","category":"page"},{"location":"changes/#v0.3.0,-April-10,-2020","page":"Changes","title":"v0.3.0, April 10, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Don't create new entry if the value to be assigned is zero, making things consistent with SparseMatrixCSC and ForwardDiff as suggested by @MaximilianJHuber","category":"page"},{"location":"changes/#v0.2.5,-Jan-26,-2020","page":"Changes","title":"v0.2.5, Jan 26, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"fixed allocations in  Base.+\nadded updateindex! method\nprovide fdrand and fdrand! matrix constructors\nautomatic benchmarks in examples","category":"page"},{"location":"changes/#v0.2.4,-Jan-19,-2020","page":"Changes","title":"v0.2.4, Jan 19, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Allow preconditioner creation directly from CSC Matrix\nRename AbstractPreconditioner to AbstractExtendablePreconditioner","category":"page"},{"location":"changes/#v0.2.3,-Jan-15,-2020","page":"Changes","title":"v0.2.3, Jan 15, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Started to introduce preconditioners (undocumented)","category":"page"},{"location":"changes/#v0.2.3,-Jan-8,-2020","page":"Changes","title":"v0.2.3, Jan 8, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"added norm, cond, opnorm methods\nresize! instead of push! when adding entries should trigger less allocation operations","category":"page"},{"location":"changes/#v0.2.2.-Dec-23,-2019","page":"Changes","title":"v0.2.2. Dec 23, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"What used to be _splice  is now + and allows now real addition (resulting in a CSC matrix)\nAdded constructors of LNK matrix from CSC matrix and vice versa\nreorganized tests","category":"page"},{"location":"changes/#v0.2.1-Dec-22,-2019","page":"Changes","title":"v0.2.1 Dec 22, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Tried to track down the source from which I learned the linked list based struct in order to document this. Ended up with SPARSEKIT of Y.Saad, however I believe this already was in SPARSEPAK by Chu,George,Liu.\nInternal rename of SparseMatrixExtension to SparseMatrixLNK.","category":"page"},{"location":"changes/#v0.2-Dec-21,-2019","page":"Changes","title":"v0.2 Dec 21, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"more interface methods delegating to csc, in particular mul! and ldiv!\nlazy creation of extendable part: don't create idle memory\nnicer constructors","category":"page"},{"location":"changes/#V0.1,-July-2019","page":"Changes","title":"V0.1, July 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Initial release","category":"page"},{"location":"iter/#Factorizations-and-Preconditioners","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"This functionality probably will be reduced in favor of LinearSolve.jl.","category":"page"},{"location":"iter/#Factorizations","page":"Factorizations & Preconditioners","title":"Factorizations","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"In this package, preconditioners and LU factorizations are both seen as complete or approximate factorizations. Correspondingly we provide a common  API for them.","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"ExtendableSparse.AbstractLUFactorization","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Modules = [ExtendableSparse]\nPages = [\"factorizations.jl\"]\nOrder = [:function, :type]\nPrivate = false","category":"page"},{"location":"iter/#ExtendableSparse.factorize!-Tuple{AbstractFactorization, ExtendableSparseMatrix}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.factorize!","text":"factorize!(factorization, matrix)\n\nUpdate or create factorization, possibly reusing information from the current state. This method is aware of pattern changes.\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.issolver-Tuple{ExtendableSparse.AbstractLUFactorization}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.issolver","text":"issolver(factorization)\n\nDetermine if factorization is a solver or not\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.update!-Tuple{AbstractFactorization}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.update!","text":"update!(factorization)\n\nUpdate factorization after matrix update.\n\n\n\n\n\n","category":"method"},{"location":"iter/#ExtendableSparse.AbstractFactorization","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AbstractFactorization","text":"abstract type AbstractFactorization\n\nAbstract type for a factorization   with ExtandableSparseMatrix. \n\nThis type is meant to be a \"type flexible\" (with respect to the matrix element type) and lazily construcdet (can be constructed without knowing the matrix, and updated later) LU factorization or preconditioner. It wraps different concrete, type fixed factorizations which shall provide the usual ldiv! methods.\n\nAny such preconditioner/factorization MyFact should have the following fields\n\n  A::ExtendableSparseMatrix\n  factorization\n  phash::UInt64\n\nand  provide methods\n\n  MyFact(;kwargs...) \n  update!(precon::MyFact)\n\nThe idea is that, depending if the matrix pattern has changed,  different steps are needed to update the preconditioner.\n\n\n\n\n\n","category":"type"},{"location":"iter/#LU-Factorizations","page":"Factorizations & Preconditioners","title":"LU Factorizations","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Handling of the LU factorizations is meant to support a workflow where sequences of problems are solved based on the same matrix, where one possibly wants to re-use existing symbolic factorization data.","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"The support comes in two flavors.","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Using factorize! which can work as a drop-in replacement for lu!:","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"using ExtendableSparse, LinearAlgebra\nA = fdrand(20, 20, 1; matrixtype = ExtendableSparseMatrix)\nn = size(A, 1)\nb = rand(n)\nfactorization = SparspakLU()\nfactorize!(factorization, A)\nnm1 = norm(factorization \\ b)\n\n# mock update from Newton etc.\nfor i = 4:(n - 3)\n    A[i, i + 3] -= 1.0e-4\nend\nfactorize!(factorization, A)\nnm2 = norm(factorization \\ b)\nnm1, nm2","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Using update!, where the matrix only needs to be given at construction time:","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"using ExtendableSparse, LinearAlgebra\nA = fdrand(20, 20, 1; matrixtype = ExtendableSparseMatrix)\nn = size(A, 1)\nb = rand(n)\nfactorization = CholeskyFactorization(A)\nnm1 = norm(factorization \\ b)\n\n# mock update from Newton etc.\nfor i = 4:(n - 3)\n    A[i, i + 3] -= 1.0e-4\n    A[i - 3, i] -= 1.0e-4\nend\nupdate!(factorization)\nnm2 = norm(factorization \\ b)\nnm1, nm2","category":"page"},{"location":"iter/#API","page":"Factorizations & Preconditioners","title":"API","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Available by default:","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Modules = [ExtendableSparse]\nPages = [\"umfpack_lu.jl\",  \"sparspak.jl\"]","category":"page"},{"location":"iter/#ExtendableSparse.LUFactorization","page":"Factorizations & Preconditioners","title":"ExtendableSparse.LUFactorization","text":"LUFactorization()\nLUFactorization(matrix)\n\nDefault LU Factorization. Maps to Sparspak.jl for non-GPL builds, otherwise to UMFPACK.\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.SparspakLU","page":"Factorizations & Preconditioners","title":"ExtendableSparse.SparspakLU","text":"SparspakLU() \nSparspakLU(matrix) \n\nLU factorization based on Sparspak.jl (P.Krysl's Julia re-implementation of Sparspak by George & Liu)\n\n\n\n\n\n","category":"type"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"ExtendableSparse.AbstractLUFactorization\nExtendableSparse.CholeskyFactorization\nBase.:\\","category":"page"},{"location":"iter/#ExtendableSparse.AbstractLUFactorization","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AbstractLUFactorization","text":"abstract type AbstractLUFactorization <: AbstractFactorization\n\nAbstract subtype for (full) LU factorizations\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.CholeskyFactorization","page":"Factorizations & Preconditioners","title":"ExtendableSparse.CholeskyFactorization","text":"CholeskyFactorization(;valuetype=Float64, indextype=Int64) CholeskyFactorization(matrix)\n\nDefault Cholesky factorization via cholmod.\n\n\n\n\n\n","category":"type"},{"location":"iter/#Base.:\\","page":"Factorizations & Preconditioners","title":"Base.:\\","text":"A\b\n\n\\ for ExtendableSparse. It calls the LU factorization form Sparspak.jl, unless GPL components are allowed  in the Julia sysimage and the floating point type of the matrix is Float64 or Complex64. In that case, Julias standard `` is called, which is realized via UMFPACK.\n\n\n\n\n\n\\(symm_ext, b)\n\n\n\\ for Symmetric{ExtendableSparse}\n\n\n\n\n\n\\(symm_ext, b)\n\n\n\\ for Hermitian{ExtendableSparse}\n\n\n\n\n\n lufact\rhs\n\nSolve  LU factorization problem.\n\n\n\n\n\n","category":"function"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Pardiso extension:","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"PardisoLU\nMKLPardisoLU","category":"page"},{"location":"iter/#ExtendableSparse.PardisoLU","page":"Factorizations & Preconditioners","title":"ExtendableSparse.PardisoLU","text":"PardisoLU(;iparm::Vector, \n           dparm::Vector, \n           mtype::Int)\n\nPardisoLU(matrix; iparm,dparm,mtype)\n\nLU factorization based on pardiso. For using this, you need to issue using Pardiso and have the pardiso library from  pardiso-project.org  installed.\n\nThe optional keyword arguments mtype, iparm  and dparm are  Pardiso internal parameters.\n\nForsetting them, one can also access the PardisoSolver e.g. like\n\nusing Pardiso\nplu=PardisoLU()\nPardiso.set_iparm!(plu.ps,5,13.0)\n\n\n\n\n\n","category":"function"},{"location":"iter/#ExtendableSparse.MKLPardisoLU","page":"Factorizations & Preconditioners","title":"ExtendableSparse.MKLPardisoLU","text":"MKLPardisoLU(;iparm::Vector, mtype::Int)\n\nMKLPardisoLU(matrix; iparm, mtype)\n\nLU factorization based on pardiso. For using this, you need to issue using Pardiso. This version  uses the early 2000's fork in Intel's MKL library.\n\nThe optional keyword arguments mtype and iparm  are   Pardiso internal parameters.\n\nFor setting them you can also access the PardisoSolver e.g. like\n\nusing Pardiso\nplu=MKLPardisoLU()\nPardiso.set_iparm!(plu.ps,5,13.0)\n\n\n\n\n\n","category":"function"},{"location":"iter/#Preconditioners","page":"Factorizations & Preconditioners","title":"Preconditioners","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"The API is similar to that for LU factorizations.","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"The support comes in two flavors.","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Using factorize!:","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"using ExtendableSparse, LinearAlgebra\nusing IterativeSolvers, IncompleteLU\nA = fdrand(20, 20, 1; matrixtype = ExtendableSparseMatrix)\nn = size(A, 1)\nb = rand(n)\npreconditioner = ILUTPreconditioner(; droptol = 1.0e-2)\nfactorize!(preconditioner, A)\n\n# mock update from Newton etc.\nnm1 = norm(bicgstabl(A, b, 1; Pl = preconditioner))\nfor i = 4:(n - 3)\n    A[i, i + 3] -= 1.0e-4\nend\nfactorize!(preconditioner, A)\nnm2 = norm(bicgstabl(A, b, 1; Pl = preconditioner))\nnm1, nm2","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Using update!:","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"using ExtendableSparse, LinearAlgebra\nusing IterativeSolvers\nA = fdrand(20, 20, 1; matrixtype = ExtendableSparseMatrix)\nn = size(A, 1)\nb = rand(n)\npreconditioner = ILU0Preconditioner(A)\nnm1 = norm(cg(A, b; Pl = preconditioner))\n\n# mock update from Newton etc.\nfor i = 4:(n - 3)\n    A[i, i + 3] -= 1.0e-4\n    A[i - 3, i] -= 1.0e-4\nend\nupdate!(preconditioner)\nnm2 = norm(cg(A, b; Pl = preconditioner))\nnm1, nm2","category":"page"},{"location":"iter/#API-2","page":"Factorizations & Preconditioners","title":"API","text":"","category":"section"},{"location":"iter/#Recommended","page":"Factorizations & Preconditioners","title":"Recommended","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Available by default:","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"ExtendableSparse.AbstractPreconditioner","category":"page"},{"location":"iter/#ExtendableSparse.AbstractPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AbstractPreconditioner","text":"abstract type AbstractPreconditioner <: AbstractFactorization\n\nAbstract subtype for preconditioners\n\n\n\n\n\n","category":"type"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Modules = [ExtendableSparse]\nPages = [\"iluzero.jl\",\"ilut.jl\",\"amg.jl\",\"blockpreconditioner.jl\"]","category":"page"},{"location":"iter/#ExtendableSparse.ILUZeroPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ILUZeroPreconditioner","text":"ILUZeroPreconditioner()\nILUZeroPreconditioner(matrix)\n\nIncomplete LU preconditioner with zero fill-in using  ILUZero.jl. This preconditioner also calculates and stores updates to the off-diagonal entries and thus delivers better convergence than  the ILU0Preconditioner.\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.PointBlockILUZeroPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.PointBlockILUZeroPreconditioner","text":"PointBlockILUZeroPreconditioner(;blocksize)\nPointBlockILUZeroPreconditioner(matrix;blocksize)\n\nIncomplete LU preconditioner with zero fill-in using  ILUZero.jl. This preconditioner also calculates and stores updates to the off-diagonal entries and thus delivers better convergence than  the ILU0Preconditioner.\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.BlockPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.BlockPreconditioner","text":" BlockPreconditioner(;partitioning, factorization=LUFactorization)\n\nCreate a block preconditioner from partition of unknowns given by partitioning, a vector of AbstractVectors describing the indices of the partitions of the matrix. For a matrix of size n x n, e.g. partitioning could be [ 1:n÷2, (n÷2+1):n] or [ 1:2:n, 2:2:n]. Factorization is a callable (Function or struct) which allows to create a factorization (with ldiv! methods) from a submatrix of A.\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.allow_views-Tuple{Any}","page":"Factorizations & Preconditioners","title":"ExtendableSparse.allow_views","text":"allow_views(::preconditioner_type)\n\nFactorizations on matrix partitions within a block preconditioner may or may not work with array views. E.g. the umfpack factorization cannot work with views, while ILUZeroPreconditioner can. Implementing a method for allow_views returning false resp. true allows to dispatch to the proper case.\n\n\n\n\n\n","category":"method"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Extensions:","category":"page"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"ILUTPreconditioner\nExtendableSparse.AMGCL_AMGPreconditioner\nExtendableSparse.AMGCL_RLXPreconditioner\nExtendableSparse.RS_AMGPreconditioner\nExtendableSparse.SA_AMGPreconditioner\nExtendableSparse.AMGPreconditioner","category":"page"},{"location":"iter/#ExtendableSparse.ILUTPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ILUTPreconditioner","text":"ILUTPreconditioner(;droptol=1.0e-3)\nILUTPreconditioner(matrix; droptol=1.0e-3)\n\nCreate the ILUTPreconditioner wrapping the one  from IncompleteLU.jl For using this, you need to issue using IncompleteLU.\n\n\n\n\n\n","category":"function"},{"location":"iter/#ExtendableSparse.AMGCL_AMGPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AMGCL_AMGPreconditioner","text":"AMGCL_AMGPreconditioner(;kwargs...)\nAMGCL_AMGPreconditioner(matrix;kwargs...)\n\nCreate the  AMGCL_AMGPreconditioner wrapping AMG preconditioner from AMGCLWrap.jl For kwargs see there.\n\n\n\n\n\n","category":"function"},{"location":"iter/#ExtendableSparse.AMGCL_RLXPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AMGCL_RLXPreconditioner","text":"AMGCL_RLXPreconditioner(;kwargs...)\nAMGCL_RLXPreconditioner(matrix;kwargs...)\n\nCreate the  AMGCL_RLXPreconditioner wrapping RLX preconditioner from AMGCLWrap.jl\n\n\n\n\n\n","category":"function"},{"location":"iter/#ExtendableSparse.RS_AMGPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.RS_AMGPreconditioner","text":"RS_AMGPreconditioner(;kwargs...)\nRS_AMGPreconditioner(matrix;kwargs...)\n\nCreate the  RS_AMGPreconditioner wrapping the Ruge-Stüben AMG preconditioner from AlgebraicMultigrid.jl For kwargs see there.\n\n\n\n\n\n","category":"function"},{"location":"iter/#ExtendableSparse.SA_AMGPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.SA_AMGPreconditioner","text":"SA_AMGPreconditioner(;kwargs...)\nSA_AMGPreconditioner(matrix;kwargs...)\n\nCreate the  SA_AMGPreconditioner wrapping the smoothed aggregation AMG preconditioner from AlgebraicMultigrid.jl For kwargs see there.\n\n\n\n\n\n","category":"function"},{"location":"iter/#ExtendableSparse.AMGPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.AMGPreconditioner","text":"AMGPreconditioner(;max_levels=10, max_coarse=10)\nAMGPreconditioner(matrix;max_levels=10, max_coarse=10)\n\nCreate the  AMGPreconditioner wrapping the Ruge-Stüben AMG preconditioner from AlgebraicMultigrid.jl\n\nwarning: Warning\nDeprecated in favor of RS_AMGPreconditioner\n\n\n\n\n\n","category":"function"},{"location":"iter/#Experimental","page":"Factorizations & Preconditioners","title":"Experimental","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"Modules = [ExtendableSparse]\nPages = [\"jacobi.jl\",\"parallel_jacobi.jl\",\"ilu0.jl\",]","category":"page"},{"location":"iter/#ExtendableSparse.JacobiPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.JacobiPreconditioner","text":"JacobiPreconditioner()\nJacobiPreconditioner(matrix)\n\nJacobi preconditioner.\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.ParallelJacobiPreconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ParallelJacobiPreconditioner","text":"ParallelJacobiPreconditioner()\nParallelJacobiPreconditioner(matrix)\n\nParallelJacobi preconditioner.\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.ILU0Preconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ILU0Preconditioner","text":"ILU0Preconditioner()\nILU0Preconditioner(matrix)\n\nIncomplete LU preconditioner with zero fill-in, without modification of off-diagonal entries, so it delivers slower convergende than  ILUZeroPreconditioner.\n\n\n\n\n\n","category":"type"},{"location":"iter/#ExtendableSparse.ParallelILU0Preconditioner","page":"Factorizations & Preconditioners","title":"ExtendableSparse.ParallelILU0Preconditioner","text":"ParallelILU0Preconditioner()\nParallelILU0Preconditioner(matrix)\n\nParallel ILU preconditioner with zero fill-in.\n\n\n\n\n\n","category":"type"},{"location":"iter/#Iteration-schemes","page":"Factorizations & Preconditioners","title":"Iteration schemes","text":"","category":"section"},{"location":"iter/","page":"Factorizations & Preconditioners","title":"Factorizations & Preconditioners","text":"ExtendableSparse.simple!","category":"page"},{"location":"iter/#ExtendableSparse.simple!","page":"Factorizations & Preconditioners","title":"ExtendableSparse.simple!","text":"simple!(u,A,b;\n                 abstol::Real = zero(real(eltype(b))),\n                 reltol::Real = sqrt(eps(real(eltype(b)))),\n                 log=false,\n                 maxiter=100,\n                 P=nothing\n                 ) -> solution, [history]\n\nSimple iteration scheme u_i+1= u_i - P^-1 (A u_i -b) with similar API as the methods in IterativeSolvers.jl.\n\n\n\n\n\n","category":"function"},{"location":"linearsolve/#Integration-with-LinearSolve.jl","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"","category":"section"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"Starting with version 0.9.6, ExtendableSparse is compatible with LinearSolve.jl. Since version 0.9.7, this is facilitated via the AbstractSparseMatrixCSC interface.","category":"page"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"Modules = [ExtendableSparse]\nPages = [\"linearsolve.jl\"]","category":"page"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"We can create a test problem and solve it with the \\ operator.","category":"page"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"using ExtendableSparse # hide\nA = fdrand(10, 10, 10; matrixtype = ExtendableSparseMatrix)\nx = ones(1000)\nb = A * x\ny = A \\ b\nsum(y)","category":"page"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"The same problem can be solved by the tools available via LinearSolve.jl:","category":"page"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"using ExtendableSparse # hide\nusing LinearSolve # hide\nA = fdrand(10, 10, 10; matrixtype = ExtendableSparseMatrix)\nx = ones(1000)\nb = A * x\ny = solve(LinearProblem(A, b), SparspakFactorization()).u\nsum(y)","category":"page"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"Also, the iterative method interface works with ExtendableSparse.","category":"page"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"using ExtendableSparse # hide\nusing LinearSolve # hide\nusing SparseArrays # hide\nusing ILUZero # hide\nA = fdrand(10, 10, 10; matrixtype = ExtendableSparseMatrix)\nx = ones(1000)\nb = A * x\ny = LinearSolve.solve(LinearProblem(A, b), KrylovJL_CG();\n                      Pl = ILUZero.ilu0(SparseMatrixCSC(A))).u\nsum(y)","category":"page"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"However, ExtendableSparse provides a number of wrappers around preconditioners from various Julia packages.","category":"page"},{"location":"linearsolve/","page":"Integration with LinearSolve.jl","title":"Integration with LinearSolve.jl","text":"using ExtendableSparse # hide\nusing LinearSolve # hide\nusing ILUZero # hide\nA = fdrand(10, 10, 10; matrixtype = ExtendableSparseMatrix)\nx = ones(1000)\nb = A * x\ny = LinearSolve.solve(LinearProblem(A, b), KrylovJL_CG();\n                      Pl = ILUZeroPreconditioner(A)).u\nsum(y)","category":"page"},{"location":"internal/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal/#Linked-List-Sparse-Matrix-format","page":"Internal API","title":"Linked List Sparse Matrix format","text":"","category":"section"},{"location":"internal/","page":"Internal API","title":"Internal API","text":"Modules = [ExtendableSparse]\nPages = [\"sparsematrixlnk.jl\"]","category":"page"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"mutable struct SparseMatrixLNK{Tv, Ti<:Integer} <: SparseArrays.AbstractSparseArray{Tv, Ti<:Integer, 2}\n\nStruct to hold sparse matrix in the linked list format.\n\nModeled after the linked list sparse matrix format described in  the  whitepaper and the  SPARSEKIT2 source code by Y. Saad. He writes \"This is one of the oldest data structures used for sparse matrix computations.\"\n\nThe relevant source formats.f is also available in the debian/science gitlab.\n\nThe advantage of the linked list structure is the fact that upon insertion of a new entry, the arrays describing the structure can grow at their respective ends and can be conveniently updated via push!.  No copying of existing data is necessary.\n\nm::Integer: Number of rows\n\nn::Integer: Number of columns\n\nnnz::Integer: Number of nonzeros\n\nnentries::Integer: Length of arrays\n\ncolptr::Vector{Ti} where Ti<:Integer: Linked list of column entries. Initial length is n, it grows with each new entry.\ncolptr[index] contains the next index in the list or zero, in the later case terminating the list which starts at index 1<=j<=n for each column j.\n\nrowval::Vector{Ti} where Ti<:Integer: Row numbers. For each index it contains the zero (initial state) or the row numbers corresponding to the column entry list in colptr.\nInitial length is n, it grows with each new entry.\n\nnzval::Vector: Nonzero entry values correspondin to each pair (colptr[index],rowval[index])\nInitial length is n,  it grows with each new entry.\n\n\n\n\n\n","category":"type"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Tuple{Any, Any}","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"SparseMatrixLNK(m, n)\n\n\nConstructor of empty matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti<:Integer}","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"SparseMatrixLNK(csc)\n\n\nConstructor from SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Any, Any}} where {Tv, Ti<:Integer}","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"SparseMatrixLNK(m, n)\n\n\nConstructor of empty matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Type{Tv}, Type{Ti}, Any, Any}} where {Tv, Ti<:Integer}","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"SparseMatrixLNK(valuetype, indextype, m, n)\n\n\nConstructor of empty matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.SparseMatrixLNK-Union{Tuple{Tv}, Tuple{Type{Tv}, Any, Any}} where Tv","page":"Internal API","title":"ExtendableSparse.SparseMatrixLNK","text":"SparseMatrixLNK(valuetype, m, n)\n\n\nConstructor of empty matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SparseArrays.SparseMatrixCSC-Tuple{SparseMatrixLNK}","page":"Internal API","title":"SparseArrays.SparseMatrixCSC","text":"SparseMatrixCSC(lnk)\n\n\nConstructor from SparseMatrixLNK.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.:+-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv, Ti}, SparseArrays.SparseMatrixCSC}} where {Tv, Ti<:Integer}","page":"Internal API","title":"Base.:+","text":"+(lnk, csc)\n\n\nAdd SparseMatrixCSC matrix and SparseMatrixLNK  lnk, returning a SparseMatrixCSC\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.getindex-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv, Ti}, Any, Any}} where {Tv, Ti}","page":"Internal API","title":"Base.getindex","text":"getindex(lnk, i, j)\n\n\nReturn value stored for entry or zero if not found\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.setindex!-Tuple{SparseMatrixLNK, Any, Any, Any}","page":"Internal API","title":"Base.setindex!","text":"setindex!(lnk, v, i, j)\n\n\nUpdate value of existing entry, otherwise extend matrix if v is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Base.size-Tuple{SparseMatrixLNK}","page":"Internal API","title":"Base.size","text":"size(lnk)\n\n\nReturn tuple containing size of the matrix.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.flush!-Union{Tuple{SparseMatrixLNK{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Internal API","title":"ExtendableSparse.flush!","text":"flush!(lnk)\n\n\nDummy flush! method for SparseMatrixLNK. Just used in test methods\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.rawupdateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv, Ti}, Vararg{Any, 4}}} where {Tv, Ti}","page":"Internal API","title":"ExtendableSparse.rawupdateindex!","text":"rawupdateindex!(lnk, op, v, i, j)\n\n\nUpdate element of the matrix  with operation op.  It assumes that op(0,0)==0. If v is zero a new entry is created nevertheless.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv, Ti}, Vararg{Any, 4}}} where {Tv, Ti}","page":"Internal API","title":"ExtendableSparse.updateindex!","text":"updateindex!(lnk, op, v, i, j)\n\n\nUpdate element of the matrix  with operation op.  It assumes that op(0,0)==0. If v is zero, no new  entry is created.\n\n\n\n\n\n","category":"method"},{"location":"internal/#SparseArrays.nnz-Tuple{SparseMatrixLNK}","page":"Internal API","title":"SparseArrays.nnz","text":"nnz(lnk)\n\n\nReturn number of nonzero entries.\n\n\n\n\n\n","category":"method"},{"location":"internal/#Some-methods-for-SparseMatrixCSC","page":"Internal API","title":"Some methods for SparseMatrixCSC","text":"","category":"section"},{"location":"internal/","page":"Internal API","title":"Internal API","text":"Modules = [ExtendableSparse]\nPages = [\"sparsematrixcsc.jl\"]","category":"page"},{"location":"internal/#ExtendableSparse.findindex-Union{Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{T}, Any, Any}} where T","page":"Internal API","title":"ExtendableSparse.findindex","text":"findindex(csc, i, j)\n\n\nReturn index corresponding to entry [i,j] in the array of nonzeros, if the entry exists, otherwise, return 0.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.flush!-Tuple{SparseArrays.SparseMatrixCSC}","page":"Internal API","title":"ExtendableSparse.flush!","text":"flush!(csc)\n\n\nTrival flush! method for allowing to run the code with both ExtendableSparseMatrix and SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.pattern_equal-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Internal API","title":"ExtendableSparse.pattern_equal","text":"pattern_equal(a::SparseMatrixCSC,b::SparseMatrixCSC)\n\nCheck if sparsity patterns of two SparseMatrixCSC objects are equal. This is generally faster than comparing hashes.\n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.phash-Tuple{SparseArrays.SparseMatrixCSC}","page":"Internal API","title":"ExtendableSparse.phash","text":"phash(csc)\n\n\nHash of csc matrix pattern. \n\n\n\n\n\n","category":"method"},{"location":"internal/#ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv, Ti}, Vararg{Any, 4}}} where {Tv, Ti<:Integer}","page":"Internal API","title":"ExtendableSparse.updateindex!","text":"updateindex!(csc, op, v, i, j)\n\n\nUpdate element of the matrix  with operation op whithout introducing new nonzero elements.\n\nThis can replace the following code and save one index search during acces:\n\nusing ExtendableSparse # hide\nusing SparseArrays # hide\nA=spzeros(3,3)\nA[1,2]+=0.1\nA\n\nusing ExtendableSparse # hide\nusing SparseArrays # hide\nA=spzeros(3,3)\nupdateindex!(A,+,0.1,1,2)\nA\n\n\n\n\n\n","category":"method"},{"location":"internal/#Misc-methods","page":"Internal API","title":"Misc methods","text":"","category":"section"},{"location":"internal/","page":"Internal API","title":"Internal API","text":"ExtendableSparse.@makefrommatrix :: Tuple{Any}","category":"page"},{"location":"internal/#ExtendableSparse.@makefrommatrix-Tuple{Tuple{Any}}","page":"Internal API","title":"ExtendableSparse.@makefrommatrix","text":"\"     @makefrommatrix(fact)\n\nFor an AbstractFactorization MyFact, provide methods\n\n    MyFact(A::ExtendableSparseMatrix; kwargs...)\n    MyFact(A::SparseMatrixCSC; kwargs...)\n\n\n\n\n\n","category":"macro"},{"location":"extsparse/#Sparse-matrix-handling","page":"Sparse matrix handling","title":"Sparse matrix handling","text":"","category":"section"},{"location":"extsparse/#Matrix-creation-and-update-API","page":"Sparse matrix handling","title":"Matrix creation and update API","text":"","category":"section"},{"location":"extsparse/","page":"Sparse matrix handling","title":"Sparse matrix handling","text":"Modules = [ExtendableSparse]\nPages = [\"extendable.jl\"]","category":"page"},{"location":"extsparse/#ExtendableSparse.ExtendableSparseMatrix","page":"Sparse matrix handling","title":"ExtendableSparse.ExtendableSparseMatrix","text":"mutable struct ExtendableSparseMatrix{Tv, Ti<:Integer} <: SparseArrays.AbstractSparseMatrixCSC{Tv, Ti<:Integer}\n\nExtendable sparse matrix. A nonzero  entry of this matrix is contained either in cscmatrix, or in lnkmatrix, never in both.\n\ncscmatrix::SparseArrays.SparseMatrixCSC: Final matrix data\n\nlnkmatrix::Union{Nothing, SparseMatrixLNK{Tv, Ti}} where {Tv, Ti<:Integer}: Linked list structure holding data of extension\n\nphash::UInt64: Pattern hash\n\n\n\n\n\n","category":"type"},{"location":"extsparse/#ExtendableSparse.ExtendableSparseMatrix-Tuple{AbstractMatrix}","page":"Sparse matrix handling","title":"ExtendableSparse.ExtendableSparseMatrix","text":"ExtendableSparseMatrix(A)\n\n\nCreate ExtendableSparseMatrix from AbstractMatrix, dropping all zero entries.  This is the equivalent to sparse(A).\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.ExtendableSparseMatrix-Tuple{Any, Any, AbstractVector}","page":"Sparse matrix handling","title":"ExtendableSparse.ExtendableSparseMatrix","text":"ExtendableSparseMatrix(I,J,V)\nExtendableSparseMatrix(I,J,V,m,n)\nExtendableSparseMatrix(I,J,V,combine::Function)\nExtendableSparseMatrix(I,J,V,m,n,combine::Function)\n\nCreate ExtendableSparseMatrix from triplet (COO) data.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.ExtendableSparseMatrix-Tuple{Diagonal}","page":"Sparse matrix handling","title":"ExtendableSparse.ExtendableSparseMatrix","text":"ExtendableSparseMatrix(D)\n\n\nCreate ExtendableSparseMatrix from Diagonal\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.SparseMatrixCSC-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.SparseMatrixCSC","text":"SparseMatrixCSC(A)\n\n\nCreate SparseMatrixCSC from ExtendableSparseMatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:*-Tuple{Diagonal, ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"Base.:*","text":"*(d, ext)\n\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:*-Tuple{ExtendableSparseMatrix, Diagonal}","page":"Sparse matrix handling","title":"Base.:*","text":"*(ext, d)\n\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:+-Tuple{ExtendableSparseMatrix, SparseArrays.SparseMatrixCSC}","page":"Sparse matrix handling","title":"Base.:+","text":"+(ext, csc)\n\n\nAdd SparseMatrixCSC matrix and ExtendableSparseMatrix  ext.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:--Tuple{ExtendableSparseMatrix, SparseArrays.SparseMatrixCSC}","page":"Sparse matrix handling","title":"Base.:-","text":"-(ext, csc)\n\n\nSubtract  SparseMatrixCSC matrix from  ExtendableSparseMatrix  ext.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:--Tuple{SparseArrays.SparseMatrixCSC, ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"Base.:-","text":"-(csc, ext)\n\n\nSubtract  ExtendableSparseMatrix  ext from  SparseMatrixCSC.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{Hermitian{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVector}} where {Tm, Ti}","page":"Sparse matrix handling","title":"Base.:\\","text":"\\(symm_ext, b)\n\n\n\\ for Hermitian{ExtendableSparse}\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:\\-Union{Tuple{Ti}, Tuple{Tm}, Tuple{Symmetric{Tm, ExtendableSparseMatrix{Tm, Ti}}, AbstractVector}} where {Tm, Ti}","page":"Sparse matrix handling","title":"Base.:\\","text":"\\(symm_ext, b)\n\n\n\\ for Symmetric{ExtendableSparse}\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.:\\-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, AbstractVector}} where {Tv, Ti}","page":"Sparse matrix handling","title":"Base.:\\","text":"A\b\n\n\\ for ExtendableSparse. It calls the LU factorization form Sparspak.jl, unless GPL components are allowed  in the Julia sysimage and the floating point type of the matrix is Float64 or Complex64. In that case, Julias standard `` is called, which is realized via UMFPACK.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.copy-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"Base.copy","text":"copy(S)\n\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.eltype-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Sparse matrix handling","title":"Base.eltype","text":"eltype(_)\n\n\nReturn element type.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.getindex-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Integer, Integer}} where {Tv, Ti<:Integer}","page":"Sparse matrix handling","title":"Base.getindex","text":"getindex(ext, i, j)\n\n\nFind index in CSC matrix and return value, if it exists. Otherwise, return value from extension.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.setindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Union{Number, AbstractVecOrMat}, Integer, Integer}} where {Tv, Ti}","page":"Sparse matrix handling","title":"Base.setindex!","text":"setindex!(ext, v, i, j)\n\n\nFind index in CSC matrix and set value if it exists. Otherwise, set index in extension if v is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"Base.show","text":"show(io, _, ext)\n\n\nShow matrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.similar-Union{Tuple{ExtendableSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Sparse matrix handling","title":"Base.similar","text":"similar(m)\n\n\nCreate similar but emtpy extendableSparseMatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#Base.size-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"Base.size","text":"size(ext)\n\n\nSize of ExtendableSparseMatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.flush!-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"ExtendableSparse.flush!","text":"flush!(ext)\n\n\nIf there are new entries in extension, create new CSC matrix by adding the cscmatrix and linked list matrix and reset the linked list based extension.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.pointblock-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Any}} where {Tv, Ti}","page":"Sparse matrix handling","title":"ExtendableSparse.pointblock","text":"pointblock(matrix,blocksize)\n\nCreate a pointblock matrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.rawupdateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{ExtendableSparseMatrix{Tv, Ti}, Vararg{Any, 4}}} where {Tv, Ti<:Integer}","page":"Sparse matrix handling","title":"ExtendableSparse.rawupdateindex!","text":"rawupdateindex!(ext, op, v, i, j)\n\n\nLike updateindex! but without  checking if v is zero.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#LinearAlgebra.cond","page":"Sparse matrix handling","title":"LinearAlgebra.cond","text":"cond(A)\ncond(A, p)\n\n\nflush! and calculate cond from cscmatrix\n\n\n\n\n\n","category":"function"},{"location":"extsparse/#LinearAlgebra.issymmetric-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"LinearAlgebra.issymmetric","text":"issymmetric(A)\n\n\nflush! and check for symmetry of cscmatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#LinearAlgebra.ldiv!-Tuple{Any, ExtendableSparseMatrix, Any}","page":"Sparse matrix handling","title":"LinearAlgebra.ldiv!","text":"ldiv!(r, ext, x)\n\n\nflush! and ldiv with ext.cscmatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#LinearAlgebra.mul!-Tuple{Any, ExtendableSparseMatrix, Any}","page":"Sparse matrix handling","title":"LinearAlgebra.mul!","text":"mul!(r, ext, x)\n\n\nflush! and multiply with ext.cscmatrix\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#LinearAlgebra.norm","page":"Sparse matrix handling","title":"LinearAlgebra.norm","text":"norm(A)\nnorm(A, p)\n\n\nflush! and calculate norm from cscmatrix\n\n\n\n\n\n","category":"function"},{"location":"extsparse/#LinearAlgebra.opnorm","page":"Sparse matrix handling","title":"LinearAlgebra.opnorm","text":"opnorm(A)\nopnorm(A, p)\n\n\nflush! and calculate opnorm from cscmatrix\n\n\n\n\n\n","category":"function"},{"location":"extsparse/#SparseArrays.dropzeros!-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.dropzeros!","text":"dropzeros!(ext)\n\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.findnz-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.findnz","text":"findnz(ext)\n\n\nflush! and return findnz(ext.cscmatrix).\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.getcolptr-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.getcolptr","text":"getcolptr(ext)\n\n\nflush! and return colptr of  in ext.cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.nnz-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.nnz","text":"nnz(ext)\n\n\nflush! and return number of nonzeros in ext.cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.nonzeros-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.nonzeros","text":"nonzeros(ext)\n\n\nflush! and return nonzeros in ext.cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#SparseArrays.rowvals-Tuple{ExtendableSparseMatrix}","page":"Sparse matrix handling","title":"SparseArrays.rowvals","text":"rowvals(ext)\n\n\nflush! and return rowvals in ext.cscmatrix.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/","page":"Sparse matrix handling","title":"Sparse matrix handling","text":"ExtendableSparse.lu\nLinearAlgebra.lu!\nLinearAlgebra.ldiv!","category":"page"},{"location":"extsparse/#ExtendableSparse.lu","page":"Sparse matrix handling","title":"ExtendableSparse.lu","text":"lu(matrix)\n\nCreate LU factorization. It calls the LU factorization form Sparspak.jl, unless GPL components are allowed  in the Julia sysimage and the floating point type of the matrix is Float64 or Complex64. In that case, Julias standard lu is called, which is realized via UMFPACK.\n\n\n\n\n\n","category":"function"},{"location":"extsparse/#LinearAlgebra.lu!","page":"Sparse matrix handling","title":"LinearAlgebra.lu!","text":"lu!(factorization, matrix)\n\nUpdate LU factorization, possibly reusing information from the current state. This method is aware of pattern changes.\n\nIf nothing is passed as first parameter, factorize! is called.\n\n\n\n\n\n","category":"function"},{"location":"extsparse/#LinearAlgebra.ldiv!","page":"Sparse matrix handling","title":"LinearAlgebra.ldiv!","text":"ldiv!(r, ext, x)\n\n\nflush! and ldiv with ext.cscmatrix\n\n\n\n\n\nldiv!(u,factorization,v)\nldiv!(factorization,v)\n\nSolve factorization.\n\n\n\n\n\n","category":"function"},{"location":"extsparse/#Test-matrix-creation","page":"Sparse matrix handling","title":"Test matrix creation","text":"","category":"section"},{"location":"extsparse/","page":"Sparse matrix handling","title":"Sparse matrix handling","text":"Modules = [ExtendableSparse]\nPages = [\"sprand.jl\"]","category":"page"},{"location":"extsparse/#ExtendableSparse.fdrand!-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}, Tuple{T, Any, Any, Any}} where T<:(AbstractMatrix)","page":"Sparse matrix handling","title":"ExtendableSparse.fdrand!","text":"fdrand!(A, nx; ...)\nfdrand!(A, nx, ny; ...)\nfdrand!(A, nx, ny, nz; update, rand)\n\n\nAfter setting  all nonzero entries  to zero, fill resp.  update matrix with finite  difference discretization data  on a unit  hypercube. See fdrand for documentation of the parameters.\n\nIt is required that size(A)==(N,N) where N=nx*ny*nz\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.fdrand-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Any}, Tuple{Type{T}, Any, Any, Any}} where T","page":"Sparse matrix handling","title":"ExtendableSparse.fdrand","text":"fdrand(, nx; ...)\nfdrand(, nx, ny; ...)\nfdrand(, nx, ny, nz; matrixtype, update, rand, symmetric)\nfdrand(nx; ...)\n\n\nCreate matrix  for a mock  finite difference operator for  a diffusion problem with random coefficients on a unit hypercube Omegasubsetmathbb R^d. with d=1 if  nx>1 && ny==1 && nz==1, d=2 if  nx>1 && ny>1 && nz==1 and d=3 if  nx>1 && ny>1 && nz>1 . In the symmetric case it corresponds to\n\n    beginalign*\n             -nabla a nabla u = f  textin  Omega  \n    anabla ucdot vec n + bu =g  texton  partialOmega\n    endalign*\n\nThe matrix is irreducibly diagonally dominant, has positive main diagonal entries  and nonpositive off-diagonal entries, hence it has the M-Property. Therefore, its inverse will be a dense matrix with positive entries, and the spectral radius of the  Jacobi iteration matrix ho(I-D(A)^-1A)1 .\n\nMoreover, in the symmetric case, it is positive definite.\n\nParameters+ default values:\n\nParameter + default vale Description\nnx Number of unknowns in x direction\nny Number of unknowns in y direction\nnz Number of unknowns in z direction\nmatrixtype = SparseMatrixCSC Matrix type\nupdate = (A,v,i,j)-> A[i,j]+=v Element update function\nrand =()-> rand() Random number generator\nsymmetric=true Whether to create symmetric matrix or not\n\nThe sparsity structure is fixed to an orthogonal grid, resulting in a 3, 5 or 7 diagonal matrix depending on dimension. The entries are random unless e.g.  rand=()->1 is passed as random number generator. Tested for Matrix, SparseMatrixCSC,  ExtendableSparseMatrix, Tridiagonal, SparseMatrixLNK and :COO\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.sprand!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.AbstractSparseMatrix{Tv, Ti}, Int64}} where {Tv, Ti}","page":"Sparse matrix handling","title":"ExtendableSparse.sprand!","text":"sprand!(A, xnnz)\n\n\nFill empty sparse matrix A with random nonzero elements from interval [1,2] using incremental assembly.\n\n\n\n\n\n","category":"method"},{"location":"extsparse/#ExtendableSparse.sprand_sdd!-Union{Tuple{SparseArrays.AbstractSparseMatrix{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Sparse matrix handling","title":"ExtendableSparse.sprand_sdd!","text":"sprand_sdd!(A; nnzrow)\n\n\nFill sparse matrix  with random entries such that  it becomes strictly diagonally  dominant  and  thus  invertible and  has  a  fixed  number nnzrow (default: 4) of nonzeros in its rows. The matrix bandwidth is bounded by  sqrt(n) in order to resemble  a typical matrix of  a 2D piecewise linear FEM discretization.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"example/#Examples-and-Benchmarks","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"","category":"section"},{"location":"example/#Matrix-creation-example","page":"Examples & Benchmarks","title":"Matrix creation example","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"An ExtendableSparseMatrix can serve as a drop-in replacement for SparseMatrixCSC, albeit with faster assembly during the buildup phase when using index based access.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Let us define a simple assembly loop","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nfunction assemble(A)\n    n = size(A, 1)\n    for i = 1:(n - 1)\n        A[i + 1, i] += -1\n        A[i, i + 1] += -1\n        A[i, i] += 1\n        A[i + 1, i + 1] += 1\n    end\nend;","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Measure the time (in seconds) for assembling a SparseMatrixCSC:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"t_csc = @belapsed begin\n    A = spzeros(10_000, 10_000)\n    assemble(A)\nend","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"An ExtendableSparseMatrix can be used as a drop-in replacement. However, before any other use, this needs an internal structure rebuild which is invoked by the flush! method.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"t_ext = @belapsed begin\n    A = ExtendableSparseMatrix(10_000, 10_000)\n    assemble(A)\n    flush!(A)\nend","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"All  specialized methods of linear algebra functions (e.g. \\) for ExtendableSparseMatrix  call flush! before proceeding.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"The overall time gain from using ExtendableSparse is:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"t_ext / t_csc","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"The reason for this situation is that the SparseMatrixCSC struct just contains the data for storing the matrix in the compressed column format. Inserting a new entry in this storage scheme is connected with serious bookkeeping and shifts of large portions of array content.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Julia provides the sparse method which  uses an intermediate  storage of  the data in  two index arrays and a value array, the so called coordinate (or COO) format:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"function assemble_coo(n)\n    I = zeros(Int64, 0)\n    J = zeros(Int64, 0)\n    V = zeros(0)\n    function update(i, j, v)\n        push!(I, i)\n        push!(J, j)\n        push!(V, v)\n    end\n    for i = 1:(n - 1)\n        update(i + 1, i, -1)\n        update(i, i + 1, -1)\n        update(i, i, 1)\n        update(i + 1, i + 1, 1)\n    end\n    sparse(I, J, V)\nend;\n\nt_coo = @belapsed assemble_coo(10_000)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"While more convenient to use, the assembly based on ExtendableSparseMatrix is only slightly slower:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"t_ext / t_coo","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Below one finds a more elaborate discussion for a quasi-3D problem.","category":"page"},{"location":"example/#Matrix-creation-benchmark","page":"Examples & Benchmarks","title":"Matrix creation benchmark","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"The method fdrand  creates a matrix similar to the discretization matrix of a Poisson equation on a d-dimensional cube. The approach is similar to that of a typical finite element code: calculate a local stiffness matrix and assemble it into the global one.","category":"page"},{"location":"example/#Benchmark-for-[ExtendableSparseMatrix](@ref)","page":"Examples & Benchmarks","title":"Benchmark for ExtendableSparseMatrix","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"The code uses the index access API for the creation of the matrix, inserting elements via A[i,j]+=v, using an intermediate linked list structure which upon return ist flushed into a SparseMatrixCSC structure.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"@belapsed fdrand(30, 30, 30, matrixtype = ExtendableSparseMatrix)","category":"page"},{"location":"example/#Benchmark-for-SparseMatrixCSC","page":"Examples & Benchmarks","title":"Benchmark for  SparseMatrixCSC","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Here, for comparison we use  a SparseMatrixCSC created with spzeros and insert entries via A[i,j]+=v.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\n@belapsed fdrand(30, 30, 30, matrixtype = SparseMatrixCSC)","category":"page"},{"location":"example/#Benchmark-for-intermediate-coordinate-format","page":"Examples & Benchmarks","title":"Benchmark for  intermediate coordinate format","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"A SparseMatrixCSC is created by accumulating data into arrays I,J,A and calling sparse(I,J,A)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\n@belapsed fdrand(30, 30, 30, matrixtype = :COO)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"This is nearly on par with matrix creation via ExtendableSparseMatrix, but the later can be made faster:","category":"page"},{"location":"example/#Benchmark-for-ExtendableSparseMatrix-with-updateindex","page":"Examples & Benchmarks","title":"Benchmark  for ExtendableSparseMatrix with updateindex","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Here, we use  a ExtendableSparseMatrix created withspzerosand insert entries viaupdateindex(A,+,v,i,j)`, see the discussion below.","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\n@belapsed fdrand(30, 30, 30,\n                 matrixtype = ExtendableSparseMatrix,\n                 update = (A, v, i, j) -> updateindex!(A, +, v, i, j))","category":"page"},{"location":"example/#Matrix-update-benchmark","page":"Examples & Benchmarks","title":"Matrix update benchmark","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"For repeated calculations on the same sparsity structure (e.g. for time dependent problems or Newton iterations) it is convenient to skip all but the first creation steps and to just replace the values in the matrix after setting the elements of the nzval vector to zero. Typically in finite element and finite volume methods this step updates matrix entries (most of them several times) by adding values. In this case, the current indexing interface of Julia requires to access the matrix twice:","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using SparseArrays     # hide\nA = spzeros(3, 3)\nMeta.@lower A[1, 2] += 3","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"For sparse matrices this requires to perform the index search in the structure twice. The packages provides the method updateindex! for both SparseMatrixCSC and for ExtendableSparse which allows to update a matrix element with just one index search.","category":"page"},{"location":"example/#Benchmark-for-SparseMatrixCSC-2","page":"Examples & Benchmarks","title":"Benchmark for SparseMatrixCSC","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nA = fdrand(30, 30, 30; matrixtype = SparseMatrixCSC)\n@belapsed fdrand!(A, 30, 30, 30,\n                  update = (A, v, i, j) -> A[i, j] += v)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing SparseArrays     # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nA = fdrand(30, 30, 30; matrixtype = SparseMatrixCSC)\n@belapsed fdrand!(A, 30, 30, 30,\n                  update = (A, v, i, j) -> updateindex!(A, +, v, i, j))","category":"page"},{"location":"example/#Benchmark-for-ExtendableSparseMatrix","page":"Examples & Benchmarks","title":"Benchmark for ExtendableSparseMatrix","text":"","category":"section"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nA = fdrand(30, 30, 30; matrixtype = ExtendableSparseMatrix)\n@belapsed fdrand!(A, 30, 30, 30,\n                  update = (A, v, i, j) -> A[i, j] += v)","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"using ExtendableSparse # hide\nusing BenchmarkTools   # hide\nBenchmarkTools.DEFAULT_PARAMETERS.seconds = 1 # hide\nA = fdrand(30, 30, 30; matrixtype = ExtendableSparseMatrix)\n@belapsed fdrand!(A, 30, 30, 30,\n                  update = (A, v, i, j) -> updateindex!(A, +, v, i, j))","category":"page"},{"location":"example/","page":"Examples & Benchmarks","title":"Examples & Benchmarks","text":"Note that the update process for ExtendableSparse may be slightly slower than for SparseMatrixCSC due to the overhead which comes from checking the presence of new entries.","category":"page"}]
}
