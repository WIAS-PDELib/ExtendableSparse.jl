<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples &amp; Benchmarks · ExtendableSparse.jl</title><meta name="title" content="Examples &amp; Benchmarks · ExtendableSparse.jl"/><meta property="og:title" content="Examples &amp; Benchmarks · ExtendableSparse.jl"/><meta property="twitter:title" content="Examples &amp; Benchmarks · ExtendableSparse.jl"/><meta name="description" content="Documentation for ExtendableSparse.jl."/><meta property="og:description" content="Documentation for ExtendableSparse.jl."/><meta property="twitter:description" content="Documentation for ExtendableSparse.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ExtendableSparse.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples &amp; Benchmarks</a><ul class="internal"><li><a class="tocitem" href="#Matrix-creation-example"><span>Matrix creation example</span></a></li><li><a class="tocitem" href="#Matrix-creation-benchmark"><span>Matrix creation benchmark</span></a></li><li><a class="tocitem" href="#Matrix-update-benchmark"><span>Matrix update benchmark</span></a></li></ul></li><li><a class="tocitem" href="../linearsolve/">Integration with LinearSolve.jl</a></li><li><a class="tocitem" href="../extsparse/">Sparse matrix handling</a></li><li><a class="tocitem" href="../iter/">Factorizations &amp; Preconditioners</a></li><li><a class="tocitem" href="../internal/">Internal API</a></li><li><a class="tocitem" href="../changes/">Changes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples &amp; Benchmarks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples &amp; Benchmarks</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/j-fu/ExtendableSparse.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples-and-Benchmarks"><a class="docs-heading-anchor" href="#Examples-and-Benchmarks">Examples &amp; Benchmarks</a><a id="Examples-and-Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-and-Benchmarks" title="Permalink"></a></h1><h2 id="Matrix-creation-example"><a class="docs-heading-anchor" href="#Matrix-creation-example">Matrix creation example</a><a id="Matrix-creation-example-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-creation-example" title="Permalink"></a></h2><p>An <code>ExtendableSparseMatrix</code> can serve as a drop-in replacement for <code>SparseMatrixCSC</code>, albeit with faster assembly during the buildup phase when using index based access.</p><p>Let us define a simple assembly loop</p><pre><code class="language-julia hljs">function assemble(A)
    n = size(A, 1)
    for i = 1:(n - 1)
        A[i + 1, i] += -1
        A[i, i + 1] += -1
        A[i, i] += 1
        A[i + 1, i + 1] += 1
    end
end;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">assemble (generic function with 1 method)</code></pre><p>Measure the time (in seconds) for assembling a SparseMatrixCSC:</p><pre><code class="language-julia hljs">t_csc = @belapsed begin
    A = spzeros(10_000, 10_000)
    assemble(A)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.018582155</code></pre><p>An <code>ExtendableSparseMatrix</code> can be used as a drop-in replacement. However, before any other use, this needs an internal structure rebuild which is invoked by the flush! method.</p><pre><code class="language-julia hljs">t_ext = @belapsed begin
    A = ExtendableSparseMatrix(10_000, 10_000)
    assemble(A)
    flush!(A)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.00131815</code></pre><p>All  specialized methods of linear algebra functions (e.g. <code>\</code>) for <code>ExtendableSparseMatrix</code>  call <code>flush!</code> before proceeding.</p><p>The overall time gain from using <code>ExtendableSparse</code> is:</p><pre><code class="language-julia hljs">t_ext / t_csc</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0709363365013369</code></pre><p>The reason for this situation is that the <code>SparseMatrixCSC</code> struct just contains the data for storing the matrix in the compressed column format. Inserting a new entry in this storage scheme is connected with serious bookkeeping and shifts of large portions of array content.</p><p>Julia provides the <a href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/#SparseArrays.sparse"><code>sparse</code></a> method which  uses an intermediate  storage of  the data in  two index arrays and a value array, the so called coordinate (or COO) format:</p><pre><code class="language-julia hljs">function assemble_coo(n)
    I = zeros(Int64, 0)
    J = zeros(Int64, 0)
    V = zeros(0)
    function update(i, j, v)
        push!(I, i)
        push!(J, j)
        push!(V, v)
    end
    for i = 1:(n - 1)
        update(i + 1, i, -1)
        update(i, i + 1, -1)
        update(i, i, 1)
        update(i + 1, i + 1, 1)
    end
    sparse(I, J, V)
end;

t_coo = @belapsed assemble_coo(10_000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.000993502</code></pre><p>While more convenient to use, the assembly based on <code>ExtendableSparseMatrix</code> is only slightly slower:</p><pre><code class="language-julia hljs">t_ext / t_coo</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.3267713602992242</code></pre><p>Below one finds a more elaborate discussion for a quasi-3D problem.</p><h2 id="Matrix-creation-benchmark"><a class="docs-heading-anchor" href="#Matrix-creation-benchmark">Matrix creation benchmark</a><a id="Matrix-creation-benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-creation-benchmark" title="Permalink"></a></h2><p>The method <a href="../extsparse/#ExtendableSparse.fdrand-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Any}, Tuple{Type{T}, Any, Any, Any}} where T"><code>fdrand</code></a>  creates a matrix similar to the discretization matrix of a Poisson equation on a d-dimensional cube. The approach is similar to that of a typical finite element code: calculate a local stiffness matrix and assemble it into the global one.</p><h3 id="Benchmark-for-[ExtendableSparseMatrix](@ref)"><a class="docs-heading-anchor" href="#Benchmark-for-[ExtendableSparseMatrix](@ref)">Benchmark for <a href="@ref"><code>ExtendableSparseMatrix</code></a></a><a id="Benchmark-for-[ExtendableSparseMatrix](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark-for-[ExtendableSparseMatrix](@ref)" title="Permalink"></a></h3><p>The code uses the index access API for the creation of the matrix, inserting elements via <code>A[i,j]+=v</code>, using an intermediate linked list structure which upon return ist flushed into a SparseMatrixCSC structure.</p><pre><code class="language-julia hljs">@belapsed fdrand(30, 30, 30, matrixtype = ExtendableSparseMatrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.010124648</code></pre><h3 id="Benchmark-for-SparseMatrixCSC"><a class="docs-heading-anchor" href="#Benchmark-for-SparseMatrixCSC">Benchmark for  SparseMatrixCSC</a><a id="Benchmark-for-SparseMatrixCSC-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark-for-SparseMatrixCSC" title="Permalink"></a></h3><p>Here, for comparison we use  a <code>SparseMatrixCSC</code> created with <code>spzeros</code> and insert entries via <code>A[i,j]+=v</code>.</p><pre><code class="language-julia hljs">@belapsed fdrand(30, 30, 30, matrixtype = SparseMatrixCSC)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.379082219</code></pre><h3 id="Benchmark-for-intermediate-coordinate-format"><a class="docs-heading-anchor" href="#Benchmark-for-intermediate-coordinate-format">Benchmark for  intermediate coordinate format</a><a id="Benchmark-for-intermediate-coordinate-format-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark-for-intermediate-coordinate-format" title="Permalink"></a></h3><p>A <code>SparseMatrixCSC</code> is created by accumulating data into arrays <code>I</code>,<code>J</code>,<code>A</code> and calling <code>sparse(I,J,A)</code></p><pre><code class="language-julia hljs">@belapsed fdrand(30, 30, 30, matrixtype = :COO)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.011111618</code></pre><p>This is nearly on par with matrix creation via <code>ExtendableSparseMatrix</code>, but the later can be made faster:</p><h3 id="Benchmark-for-ExtendableSparseMatrix-with-updateindex"><a class="docs-heading-anchor" href="#Benchmark-for-ExtendableSparseMatrix-with-updateindex">Benchmark  for <code>ExtendableSparseMatrix</code> with <code>updateindex</code></a><a id="Benchmark-for-ExtendableSparseMatrix-with-updateindex-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark-for-ExtendableSparseMatrix-with-updateindex" title="Permalink"></a></h3><p>Here, we use  a <code>ExtendableSparseMatrix created with</code>spzeros<code>and insert entries via</code>updateindex(A,+,v,i,j)`, see the discussion below.</p><pre><code class="language-julia hljs">@belapsed fdrand(30, 30, 30,
                 matrixtype = ExtendableSparseMatrix,
                 update = (A, v, i, j) -&gt; updateindex!(A, +, v, i, j))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.00777176</code></pre><h2 id="Matrix-update-benchmark"><a class="docs-heading-anchor" href="#Matrix-update-benchmark">Matrix update benchmark</a><a id="Matrix-update-benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-update-benchmark" title="Permalink"></a></h2><p>For repeated calculations on the same sparsity structure (e.g. for time dependent problems or Newton iterations) it is convenient to skip all but the first creation steps and to just replace the values in the matrix after setting the elements of the <code>nzval</code> vector to zero. Typically in finite element and finite volume methods this step updates matrix entries (most of them several times) by adding values. In this case, the current indexing interface of Julia requires to access the matrix twice:</p><pre><code class="language-julia hljs">A = spzeros(3, 3)
Meta.@lower A[1, 2] += 3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">:($(Expr(:thunk, CodeInfo(
   <span class="sgr33"> @ none within `top-level scope`</span>
<span class="sgr90">1 ─</span> %1 = Base.getindex(A, 1, 2)
<span class="sgr90">│  </span> %2 = %1 + 3
<span class="sgr90">│  </span>      Base.setindex!(A, %2, 1, 2)
<span class="sgr90">└──</span>      return %2
))))</code></pre><p>For sparse matrices this requires to perform the index search in the structure twice. The packages provides the method <a href="../internal/#ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv, Ti}, Vararg{Any, 4}}} where {Tv, Ti}"><code>updateindex!</code></a> for both <code>SparseMatrixCSC</code> and for <code>ExtendableSparse</code> which allows to update a matrix element with just one index search.</p><h3 id="Benchmark-for-SparseMatrixCSC-2"><a class="docs-heading-anchor" href="#Benchmark-for-SparseMatrixCSC-2">Benchmark for <code>SparseMatrixCSC</code></a><a class="docs-heading-anchor-permalink" href="#Benchmark-for-SparseMatrixCSC-2" title="Permalink"></a></h3><pre><code class="language-julia hljs">A = fdrand(30, 30, 30; matrixtype = SparseMatrixCSC)
@belapsed fdrand!(A, 30, 30, 30,
                  update = (A, v, i, j) -&gt; A[i, j] += v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.005129</code></pre><pre><code class="language-julia hljs">A = fdrand(30, 30, 30; matrixtype = SparseMatrixCSC)
@belapsed fdrand!(A, 30, 30, 30,
                  update = (A, v, i, j) -&gt; updateindex!(A, +, v, i, j))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.002701481</code></pre><h3 id="Benchmark-for-ExtendableSparseMatrix"><a class="docs-heading-anchor" href="#Benchmark-for-ExtendableSparseMatrix">Benchmark for <code>ExtendableSparseMatrix</code></a><a id="Benchmark-for-ExtendableSparseMatrix-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark-for-ExtendableSparseMatrix" title="Permalink"></a></h3><pre><code class="language-julia hljs">A = fdrand(30, 30, 30; matrixtype = ExtendableSparseMatrix)
@belapsed fdrand!(A, 30, 30, 30,
                  update = (A, v, i, j) -&gt; A[i, j] += v)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.00475093</code></pre><pre><code class="language-julia hljs">A = fdrand(30, 30, 30; matrixtype = ExtendableSparseMatrix)
@belapsed fdrand!(A, 30, 30, 30,
                  update = (A, v, i, j) -&gt; updateindex!(A, +, v, i, j))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.002560146</code></pre><p>Note that the update process for <code>ExtendableSparse</code> may be slightly slower than for <code>SparseMatrixCSC</code> due to the overhead which comes from checking the presence of new entries.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../linearsolve/">Integration with LinearSolve.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 17 July 2024 08:40">Wednesday 17 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
