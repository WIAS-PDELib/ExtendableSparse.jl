<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · ExtendableSparse.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ExtendableSparse.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Matrix-creation"><span>Matrix creation</span></a></li><li><a class="tocitem" href="#Matrix-update"><span>Matrix update</span></a></li></ul></li><li><a class="tocitem" href="../changes/">Changes</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/j-fu/ExtendableSparse.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Matrix-creation"><a class="docs-heading-anchor" href="#Matrix-creation">Matrix creation</a><a id="Matrix-creation-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-creation" title="Permalink"></a></h2><p>An <code>ExtendableSparseMatrix</code> can serve as a drop-in replacement for <code>SparseMatrixCSC</code>, albeit with faster assembly during the buildup phase when using index based access. That means that code similar to the following example should be fast enough to avoid the assembly steps using the coordinate format:</p><pre><code class="language-julia">n=3
A=ExtendableSparseMatrix(n,n)
for i=1:n-1
    A[i,i+1]=i
end
A</code></pre><pre class="documenter-example-output">3×3 ExtendableSparseMatrix{Float64,Int64} with 2 stored entries:
  [1, 2]  =  1.0
  [2, 3]  =  2.0</pre><h3 id="Benchmark"><a class="docs-heading-anchor" href="#Benchmark">Benchmark</a><a id="Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark" title="Permalink"></a></h3><p>The method <a href="../api/#ExtendableSparse.fdrand-Union{Tuple{Tv}, Tuple{Any,Any,Any}} where Tv"><code>fdrand</code></a>  creates a matrix similar to the discetization matrix of a Poisson equation on a d-dimensional cube. The code uses the index access API for the creation of the matrix. This approach is considerably faster with  the <a href="../api/#ExtendableSparse.ExtendableSparseMatrix"><code>ExtendableSparseMatrix</code></a> which uses a linked list based structure  <a href="../api/#ExtendableSparse.SparseMatrixLNK"><code>SparseMatrixLNK</code></a> to grab new entries.</p><pre><code class="language-julia">@benchmark fdrand(30,30,30, matrixtype=ExtendableSparseMatrix);</code></pre><pre class="documenter-example-output">BenchmarkTools.Trial: 
  memory estimate:  8.16 MiB
  allocs estimate:  28
  --------------
  minimum time:     12.851 ms (0.00% GC)
  median time:      13.086 ms (0.00% GC)
  mean time:        13.215 ms (1.11% GC)
  maximum time:     14.084 ms (6.08% GC)
  --------------
  samples:          379
  evals/sample:     1</pre><pre><code class="language-julia">@benchmark fdrand(30,30,30, matrixtype=SparseMatrixCSC);</code></pre><pre class="documenter-example-output">BenchmarkTools.Trial: 
  memory estimate:  6.21 MiB
  allocs estimate:  38
  --------------
  minimum time:     458.635 ms (0.00% GC)
  median time:      459.613 ms (0.00% GC)
  mean time:        459.841 ms (0.02% GC)
  maximum time:     462.898 ms (0.19% GC)
  --------------
  samples:          11
  evals/sample:     1</pre><h2 id="Matrix-update"><a class="docs-heading-anchor" href="#Matrix-update">Matrix update</a><a id="Matrix-update-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-update" title="Permalink"></a></h2><p>For repeated calculations on the same sparsity structure (e.g. for time dependent problems or Newton iterations) it is convenient to skip all but the first creation steps and to just replace the values in the matrix after setting then elements of the <code>nzval</code>  vector to zero. Typically in finite element and finite volume methods this step updates matrix entries (most of them several times) by adding values. In this case, the current indexing interface of Julia requires to access the matrix twice:</p><pre><code class="language-julia">A=spzeros(3,3)
Meta.@lower A[1,2]+=3</code></pre><pre class="documenter-example-output">:($(Expr(:thunk, CodeInfo(
    @ none within `top-level scope&#39;
1 ─ %1 = Base.getindex(A, 1, 2)
│   %2 = %1 + 3
│        Base.setindex!(A, %2, 1, 2)
└──      return %2
))))</pre><p>For sparse matrices this requires to the index search in the structure twice. The packages provides the method <a href="../api/#ExtendableSparse.updateindex!-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixLNK{Tv,Ti},Any,Any,Integer,Integer}} where Ti&lt;:Integer where Tv"><code>updateindex!</code></a> for both <code>SparseMatrixCSC</code> and  for <code>ExtendableSparse</code> which allows to update a matrix element with one index search.</p><h3 id="Benchmark-for-SparseMatrixCSC"><a class="docs-heading-anchor" href="#Benchmark-for-SparseMatrixCSC">Benchmark for <code>SparseMatrixCSC</code></a><a id="Benchmark-for-SparseMatrixCSC-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark-for-SparseMatrixCSC" title="Permalink"></a></h3><pre><code class="language-julia">A=fdrand(30,30,30, matrixtype=SparseMatrixCSC);
@benchmark fdrand!(A,30,30,30, update=(A,v,i,j)-&gt; A[i,j]+=v);</code></pre><pre class="documenter-example-output">BenchmarkTools.Trial: 
  memory estimate:  48 bytes
  allocs estimate:  1
  --------------
  minimum time:     6.342 ms (0.00% GC)
  median time:      6.360 ms (0.00% GC)
  mean time:        6.364 ms (0.00% GC)
  maximum time:     6.964 ms (0.00% GC)
  --------------
  samples:          786
  evals/sample:     1</pre><pre><code class="language-julia">A=fdrand(30,30,30, matrixtype=SparseMatrixCSC);
@benchmark fdrand!(A,30,30,30, update=(A,v,i,j)-&gt; updateindex!(A,+,v,i,j));</code></pre><pre class="documenter-example-output">BenchmarkTools.Trial: 
  memory estimate:  48 bytes
  allocs estimate:  1
  --------------
  minimum time:     4.168 ms (0.00% GC)
  median time:      4.195 ms (0.00% GC)
  mean time:        4.200 ms (0.00% GC)
  maximum time:     9.501 ms (0.00% GC)
  --------------
  samples:          1191
  evals/sample:     1</pre><h3 id="Benchmark-for-ExtendableSparseMatrix"><a class="docs-heading-anchor" href="#Benchmark-for-ExtendableSparseMatrix">Benchmark for <code>ExtendableSparseMatrix</code></a><a id="Benchmark-for-ExtendableSparseMatrix-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmark-for-ExtendableSparseMatrix" title="Permalink"></a></h3><pre><code class="language-julia">A=fdrand(30,30,30, matrixtype=ExtendableSparseMatrix);
@benchmark fdrand!(A,30,30,30, update=(A,v,i,j)-&gt; A[i,j]+=v);</code></pre><pre class="documenter-example-output">BenchmarkTools.Trial: 
  memory estimate:  0 bytes
  allocs estimate:  0
  --------------
  minimum time:     7.332 ms (0.00% GC)
  median time:      7.410 ms (0.00% GC)
  mean time:        7.412 ms (0.00% GC)
  maximum time:     7.732 ms (0.00% GC)
  --------------
  samples:          675
  evals/sample:     1</pre><pre><code class="language-julia">A=fdrand(30,30,30, matrixtype=ExtendableSparseMatrix);
@benchmark fdrand!(A,30,30,30, update=(A,v,i,j)-&gt; updateindex!(A,+,v,i,j));</code></pre><pre class="documenter-example-output">BenchmarkTools.Trial: 
  memory estimate:  0 bytes
  allocs estimate:  0
  --------------
  minimum time:     3.903 ms (0.00% GC)
  median time:      3.918 ms (0.00% GC)
  mean time:        3.920 ms (0.00% GC)
  maximum time:     4.136 ms (0.00% GC)
  --------------
  samples:          1276
  evals/sample:     1</pre><p>Note that the update process for <code>ExtendableSparse</code> is slightly slower than for <code>SparseMatrixCSC</code> due to the overhead which comes from checking the presence of new entries.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../changes/">Changes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 21 December 2020 15:48">Monday 21 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
